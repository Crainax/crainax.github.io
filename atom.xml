<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[梦醒依旧流年.]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://crainax.github.io/"/>
  <updated>2016-04-19T13:47:56.784Z</updated>
  <id>http://crainax.github.io/</id>
  
  <author>
    <name><![CDATA[Crainax]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[MysteryGank项目的技术要点(一)]]></title>
    <link href="http://crainax.github.io/2016/04/18/Android/MysteryGank%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9(%E4%B8%80)/"/>
    <id>http://crainax.github.io/2016/04/18/Android/MysteryGank项目的技术要点(一)/</id>
    <published>2016-04-17T16:00:00.000Z</published>
    <updated>2016-04-19T13:47:56.784Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>  近3个月没动手写Android项目了,这个期间一直在看书,感觉有时也只能浅显地了解技术表面的东西,没真正地动手去写一些东西,部分自身存在的问题不能被发现,技术是会处于瓶颈期不能有所提升的.所以此时通过上网了解了一下,gank.io里面有开放的api适合当练手的项目.github上也有几个关于的项目做为参考,再也合适不过了.于是一言不合项目就开始啦,取名为MysteryGank,中文名叫<code>蜜汁Gank</code>,别吐槽哈.</p>
<blockquote>
<p>其中Gank.io的API网站:<a href="http://gank.io/api" target="_blank" rel="external">http://gank.io/api</a></p>
</blockquote>
<h2 id="1-Retrofit2_u548CRxJava_u76F8_u7ED3_u5408_u83B7_u53D6_u6570_u636E"><a href="#1-Retrofit2_u548CRxJava_u76F8_u7ED3_u5408_u83B7_u53D6_u6570_u636E" class="headerlink" title="1.Retrofit2和RxJava相结合获取数据"></a>1.Retrofit2和RxJava相结合获取数据</h2><p>  <code>Retrofit</code>能使用<code>RESTful</code>的架构方法实现对网络的超方便请求, 不熟悉可以<a href="http://square.github.io/retrofit" target="_blank" rel="external">点这查看官网</a>.<br>  而<code>RxJava</code>作为<code>ReactiveX Java</code>的简写,是响应式编程的代表,看其在<code>Github</code>的star数目就知道其多受欢迎啦,使用过后你会发现你会离不开它了.不熟悉可以<a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">看下扔物线大神写的RxJava的博文,个人觉得写得十分不错</a>.  </p>
<h3 id="1-1_u6DFB_u52A0_u4F9D_u8D56"><a href="#1-1_u6DFB_u52A0_u4F9D_u8D56" class="headerlink" title="1.1添加依赖"></a>1.1添加依赖</h3><p>  首先在项目(app)的<code>build.gradle</code>加入这些库的依赖,代码如下:<br>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'io.reactivex:rxjava:1.1.3'</span></span><br><span class="line"><span class="keyword">compile</span> <span class="string">'io.reactivex:rxandroid:1.1.0'</span></span><br><span class="line"><span class="keyword">compile</span> <span class="string">'com.squareup.retrofit2:retrofit:2.0.2'</span></span><br><span class="line"><span class="keyword">compile</span> <span class="string">'com.squareup.retrofit2:converter-gson:2.0.2'</span></span><br><span class="line"><span class="keyword">compile</span> <span class="string">'com.squareup.retrofit2:adapter-rxjava:2.0.2'</span></span><br></pre></td></tr></table></figure></p>
<p>  注意:  </p>
<ul>
<li><code>adapter-rxjava</code>这个库是<code>retrofit2</code>用于适配<code>rxjava</code>的接口的库,采用的是设计模式中的适配器模式,注意版本要与<code>Retrofit2</code>的一致,不然在运行中会报出错误,而且特别难找出这个错误的原因!</li>
</ul>
<h3 id="1-2__u521B_u5EFABean_u7C7B"><a href="#1-2__u521B_u5EFABean_u7C7B" class="headerlink" title="1.2 创建Bean类"></a>1.2 创建Bean类</h3><p><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-4-19/71710396.jpg" alt=""><br>  根据返回的Json结果,我们使用GsonFormat对json数据做出格式化处理<a href="/https
    :/github.com/zzz40500/GsonFormat">(没听说过GsonF可以点这里)</a>:  </p>
<p><strong>MeiZhiEntity.java:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeiZhi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String _id;</span><br><span class="line">  <span class="keyword">private</span> Date createdAt;</span><br><span class="line">  <span class="keyword">private</span> String desc;</span><br><span class="line">  <span class="keyword">private</span> Date publishedAt;</span><br><span class="line">  <span class="keyword">private</span> String source;</span><br><span class="line">  <span class="keyword">private</span> String type;</span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> used;</span><br><span class="line">  <span class="keyword">private</span> String who;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"MeiZhi&#123;"</span> +</span><br><span class="line">              <span class="string">"_id='"</span> + _id + <span class="string">'\''</span> +</span><br><span class="line">              <span class="string">", createdAt='"</span> + createdAt + <span class="string">'\''</span> +</span><br><span class="line">              <span class="string">", desc='"</span> + desc + <span class="string">'\''</span> +</span><br><span class="line">              <span class="string">", publishedAt='"</span> + publishedAt + <span class="string">'\''</span> +</span><br><span class="line">              <span class="string">", source='"</span> + source + <span class="string">'\''</span> +</span><br><span class="line">              <span class="string">", type='"</span> + type + <span class="string">'\''</span> +</span><br><span class="line">              <span class="string">", url='"</span> + url + <span class="string">'\''</span> +</span><br><span class="line">              <span class="string">", used="</span> + used +</span><br><span class="line">              <span class="string">", who='"</span> + who + <span class="string">'\''</span> +</span><br><span class="line">              <span class="string">'&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Getter 和 Setter 方法省略</span></span><br></pre></td></tr></table></figure></p>
<p>还有一个类是<code>RelaxVedioEntity.java</code>,也是通过访问<code>http://gank.io/api/data/休息视频/10/1</code>获取json代码后生成的对象,这里就不贴代码了.</p>
<p>需要注意的地方:</p>
<ul>
<li>在使用GsonFormat的时候,注意手动把需要解析成为日期的改成Date类.</li>
<li>为了方便调试,记得生成toString方法.</li>
</ul>
<h3 id="1-3__u521B_u5EFA_u63A5_u6536API_u7684_u63A5_u53E3"><a href="#1-3__u521B_u5EFA_u63A5_u6536API_u7684_u63A5_u53E3" class="headerlink" title="1.3 创建接收API的接口"></a>1.3 创建接收API的接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GankAPI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/api/data/&#123;type&#125;/&#123;num&#125;/&#123;page&#125;"</span>)</span><br><span class="line">    Observable&lt;HttpResult&lt;List&lt;MeiZhi&gt;&gt;&gt; getGankData(<span class="meta">@Path</span>(<span class="string">"type"</span>) String type, <span class="meta">@Path</span>(<span class="string">"num"</span>) String num, <span class="meta">@Path</span>(<span class="string">"page"</span>) String page);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/api/data/福利/"</span> + CrainaxRetrofit.NUMBER_PER_PAGE + <span class="string">"/&#123;page&#125;"</span>)</span><br><span class="line">    Observable&lt;HttpResult&lt;List&lt;MeiZhi&gt;&gt;&gt; getMeizhi(<span class="meta">@Path</span>(<span class="string">"page"</span>) String page);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/api/data/休息视频/"</span> + CrainaxRetrofit.NUMBER_PER_PAGE + <span class="string">"/&#123;page&#125;"</span>)</span><br><span class="line">    Observable&lt;HttpResult&lt;List&lt;RelaxVideo&gt;&gt;&gt; getRelaxVedio(<span class="meta">@Path</span>(<span class="string">"page"</span>) String page);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只写出了休息视频和妹子的路径,对于干货的获取方式,类似.</p>
<ul>
<li>其中的<code>GankRetrofit.NUMBER_PER_PAGE</code>是常量 10,写在单例类里面,方便修改.</li>
</ul>
<h3 id="1-4__u521B_u5EFA_u5DE5_u5382_u7C7B_2C_u5E76_u521B_u5EFA_u5355_u4F8B_u5BF9_u8C61"><a href="#1-4__u521B_u5EFA_u5DE5_u5382_u7C7B_2C_u5E76_u521B_u5EFA_u5355_u4F8B_u5BF9_u8C61" class="headerlink" title="1.4 创建工厂类,并创建单例对象"></a>1.4 创建工厂类,并创建单例对象</h3><p>单例类<strong>GankRetrofit</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GankRetrofit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Retrofit retrofit;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 定义在APi里面的常数</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER_PER_PAGE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GankAPI gankAPI;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Retrofit <span class="title">getRetrofit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> retrofit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GankAPI <span class="title">getGankAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gankAPI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GankRetrofit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Gson gson = <span class="keyword">new</span> GsonBuilder()</span><br><span class="line">                .setDateFormat(<span class="string">"yyyy-MM-dd'T'14:42:21.265Z"</span>)</span><br><span class="line">                .serializeNulls()</span><br><span class="line">                .create();</span><br><span class="line"></span><br><span class="line">        retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(<span class="string">"http://gank.io/"</span>)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create(gson))</span><br><span class="line">                <span class="comment">//这里不能省略,用于适配RxJava的接口</span></span><br><span class="line">                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        gankAPI = retrofit.create(GankAPI.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> GankRetrofit INSTANCE = <span class="keyword">new</span> GankRetrofit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 返回单例</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GankRetrofit <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>单例模式使用的是内部类Holder单例方法,详情可以看这里<a href="http://www.race604.com/java-double-checked-singleton/" target="_blank" rel="external">Java 单例真的写对了么?</a>.</li>
<li>注意Gson对象要为其设置特定的日期解析格式,依据返回的json格式而定.</li>
</ul>
<p>工厂类<strong>APIFactory.java</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GankAPI <span class="title">getGankAPI</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GankRetrofit.getInstance().getGankAPI();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-5__u5199_u51FA_u8C03_u8BD5_u4EE3_u7801"><a href="#1-5__u5199_u51FA_u8C03_u8BD5_u4EE3_u7801" class="headerlink" title="1.5 写出调试代码"></a>1.5 写出调试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">GankAPI gankAPI = APIFactory.getGankAPI();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取休息视频与妹子的接口,并剥离其"error"外壳.</span></span><br><span class="line">       Observable&lt;List&lt;RelaxVideoEntity&gt;&gt; oRelaxVideo = gankAPI.getRelaxVedio(<span class="string">"1"</span>)</span><br><span class="line">               .map(<span class="keyword">new</span> HttpMethod&lt;List&lt;RelaxVideoEntity&gt;&gt;());</span><br><span class="line">       Observable&lt;List&lt;MeizhiEntity&gt;&gt; oMeizhi = gankAPI.getMeizhi(<span class="string">"1"</span>)</span><br><span class="line">               .map(<span class="keyword">new</span> HttpMethod&lt;List&lt;MeizhiEntity&gt;&gt;());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//不使用匿名内部类的形式,方便返回</span></span><br><span class="line">       Subscriber&lt;List&lt;MeizhiEntity&gt;&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;List&lt;MeizhiEntity&gt;&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               Log.i(TAG, <span class="string">"onCompleted."</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">               Log.w(TAG, <span class="string">"onError: "</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(List&lt;MeizhiEntity&gt; meiZhis)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">for</span> (MeizhiEntity meiZhi : meiZhis) &#123;</span><br><span class="line">                   Log.i(TAG, <span class="string">"onNext: "</span> + meiZhi);</span><br><span class="line">               &#125;</span><br><span class="line">               Log.i(TAG, <span class="string">"onNext Thread: "</span> + Thread.currentThread());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//将休息视频的描述用zip整合到妹子中去</span></span><br><span class="line">       Observable.zip(oRelaxVideo, oMeizhi, <span class="keyword">new</span> Func2&lt;List&lt;RelaxVideoEntity&gt;, List&lt;MeizhiEntity&gt;, List&lt;MeizhiEntity&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> List&lt;MeizhiEntity&gt; <span class="title">call</span><span class="params">(List&lt;RelaxVideoEntity&gt; relaxVideos, List&lt;MeizhiEntity&gt; meiZhis)</span> </span>&#123;</span><br><span class="line">               Log.i(TAG, <span class="string">"call: "</span> + Thread.currentThread().getName());</span><br><span class="line">               <span class="keyword">for</span> (MeizhiEntity meiZhi : meiZhis) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span> (RelaxVideoEntity relaxVideo : relaxVideos) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (meiZhi.getPublishedAt().equals(relaxVideo.getPublishedAt())) &#123;</span><br><span class="line">                           meiZhi.setDesc(meiZhi.getDesc() + <span class="string">" : "</span> + relaxVideo.getDesc());</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> meiZhis;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;)</span><br><span class="line">               <span class="comment">//获取网络数据,我们在IO线程中.</span></span><br><span class="line">               .subscribeOn(Schedulers.io())</span><br><span class="line">               .observeOn(Schedulers.computation())</span><br><span class="line">               <span class="comment">//用于排序的Computation线程.</span></span><br><span class="line">               .map(<span class="keyword">new</span> Func1&lt;List&lt;MeizhiEntity&gt;, List&lt;MeizhiEntity&gt;&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> List&lt;MeizhiEntity&gt; <span class="title">call</span><span class="params">(List&lt;MeizhiEntity&gt; meiZhis)</span> </span>&#123;</span><br><span class="line">                       Log.i(TAG, <span class="string">"sorting in :"</span> + Thread.currentThread().getName());</span><br><span class="line">                       <span class="keyword">return</span> meiZhis;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)</span><br><span class="line">               <span class="comment">//返回的接口,用于在Android UI线程.</span></span><br><span class="line">               .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">               .subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对于zip功能:  </p>
<blockquote>
<p>将两个retrofit接口请求后得到的两个数据源Observable Observable进行合并<br>我们需要把这两个数据源的数据拼接起来，所以我们可以考虑使用zip操作符，该操作符可以将两个数据源发射出来的数据依次组装在一起。<br>比如一个Observable数据源依次发射出1, 3, 5, 7, 另一个Observable数据源依次发射出a, b, c, d，那么zip操作符组装后会对外发射出1a, 3b, 5c, 7d这样的数据。<br><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-4-19/4473805.jpg" alt="">  </p>
<h4 id="u5728_u8FD9_u91CC_u6211_u4EEC_u8981_u628ARelaxVideo_u4E2D_u7684Desc_28_u56FE_u7247_u63CF_u8FF0_29_u53D6_u51FA_u653E_u5728Meizhi_u5B9E_u4F8B_u4E2D_2C_u6240_u4EE5_u9700_u8981_u7528_u5230_u8FD9_u4E2A_u65B9_u6CD5-_u81F3_u4E8E_u8FD4_u56DE_u503C_2C_u6211_u4EEC_u8FD8_u662F_u9009_u62E9Meizhi_u8FD9_u4E2A_u7C7B_2C_u91CD_u590D_u5229_u7528_2C_u800C_u4E0D_u5FC5_u65B0_u5EFA_u4E00_u4E2A_u7EC4_u5408_u7C7B"><a href="#u5728_u8FD9_u91CC_u6211_u4EEC_u8981_u628ARelaxVideo_u4E2D_u7684Desc_28_u56FE_u7247_u63CF_u8FF0_29_u53D6_u51FA_u653E_u5728Meizhi_u5B9E_u4F8B_u4E2D_2C_u6240_u4EE5_u9700_u8981_u7528_u5230_u8FD9_u4E2A_u65B9_u6CD5-_u81F3_u4E8E_u8FD4_u56DE_u503C_2C_u6211_u4EEC_u8FD8_u662F_u9009_u62E9Meizhi_u8FD9_u4E2A_u7C7B_2C_u91CD_u590D_u5229_u7528_2C_u800C_u4E0D_u5FC5_u65B0_u5EFA_u4E00_u4E2A_u7EC4_u5408_u7C7B" class="headerlink" title="在这里我们要把RelaxVideo中的Desc(图片描述)取出放在Meizhi实例中,所以需要用到这个方法.至于返回值,我们还是选择Meizhi这个类,重复利用,而不必新建一个组合类."></a>在这里我们要把<code>RelaxVideo</code>中的<code>Desc</code>(图片描述)取出放在<code>Meizhi</code>实例中,所以需要用到这个方法.至于返回值,我们还是选择Meizhi这个类,重复利用,而不必新建一个组合类.</h4></blockquote>
</li>
<li><p>其中的map功能,第一个,在于创建将Json数据中的”error: false”给剥离,如果这个字段为true,则抛出一个我们自己定义的异常<code>ApiException</code>,用于在<code>Subscriber</code>去处理这个异常.</p>
</li>
<li>第二个map,在其前面使用到<code>Schedulers.computation()</code>指定为计算的线程,在里面完成排序的过程,以日期作为排序字段.</li>
</ul>
<blockquote>
<p>通过这段代码,我们可以看出RxJava的优势所在,实力解耦.</p>
</blockquote>
<p>然后我们可以简单的调试一下,发现调试结果也符合我们所需要:<br><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-4-19/84532480.jpg" alt=""></p>
<h3 id="1-6__u5728"><a href="#1-6__u5728" class="headerlink" title="1.6 在"></a>1.6 在</h3>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>  近3个月没动手写Android项目了,这个期间一直在看书,感觉有时也只能浅显地了解技术表面的东西,没]]>
    </summary>
    
      <category term="android" scheme="http://crainax.github.io/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android收藏开源项目汇总]]></title>
    <link href="http://crainax.github.io/2016/04/15/Android/Android%E6%94%B6%E8%97%8F%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    <id>http://crainax.github.io/2016/04/15/Android/Android收藏开源项目/</id>
    <published>2016-04-15T13:05:07.981Z</published>
    <updated>2016-04-15T13:11:15.107Z</updated>
    <content type="html"><![CDATA[<h2 id="DMPlayer"><a href="#DMPlayer" class="headerlink" title="DMPlayer"></a>DMPlayer</h2><blockquote>
<p>一个Android 音乐播放器的原型.</p>
</blockquote>
<p><img src="https://cloud.githubusercontent.com/assets/10453203/14409496/88646b84-ff32-11e5-8923-c8093e9bfb81.png" alt=""><br><img src="https://cloud.githubusercontent.com/assets/10453203/14409497/8bdefa36-ff32-11e5-8f88-b408eaf420c5.png" alt=""><br><img src="https://cloud.githubusercontent.com/assets/10453203/14409498/8c130d1c-ff32-11e5-92de-60eb154d6a9e.png" alt=""><br><img src="https://cloud.githubusercontent.com/assets/10453203/14409499/8c412ec2-ff32-11e5-892e-2ef6e26f88ef.png" alt=""><br><img src="https://cloud.githubusercontent.com/assets/10453203/14409500/8c45d120-ff32-11e5-903d-ed27e4d4b50c.png" alt=""><br><img src="https://cloud.githubusercontent.com/assets/10453203/14409501/8c4f6762-ff32-11e5-938d-048dc5164073.png" alt=""><br><img src="https://cloud.githubusercontent.com/assets/10453203/14409502/8c54caf4-ff32-11e5-83bf-88bb1d56465f.png" alt=""><br><img src="https://cloud.githubusercontent.com/assets/10453203/14409503/8d0ed818-ff32-11e5-97e5-b9ccd7919e18.png" alt=""><br><img src="https://cloud.githubusercontent.com/assets/10453203/14409504/8d98e09e-ff32-11e5-9994-2f604f2db5f3.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="DMPlayer"><a href="#DMPlayer" class="headerlink" title="DMPlayer"></a>DMPlayer</h2><blockquote>
<p>一个Android 音乐播放器的原型.</p>
</blockqu]]>
    </summary>
    
      <category term="android" scheme="http://crainax.github.io/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中内部类使用方面的总结]]></title>
    <link href="http://crainax.github.io/2016/03/31/Java/Java%E4%B8%AD%E5%86%85%E9%83%A8%E7%B1%BB%E4%BD%BF%E7%94%A8%E6%96%B9%E9%9D%A2%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://crainax.github.io/2016/03/31/Java/Java中内部类使用方面的总结/</id>
    <published>2016-03-31T08:26:30.515Z</published>
    <updated>2016-04-01T13:49:18.732Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>以下知识点通过阅读Thinking in Java总结,也是平常不怎么接触到的技巧.</p>
</blockquote>
<h2 id="u5185_u90E8_u975E_u9759_u6001_u7C7B_u7684_u521B_u5EFA"><a href="#u5185_u90E8_u975E_u9759_u6001_u7C7B_u7684_u521B_u5EFA" class="headerlink" title="内部非静态类的创建"></a>内部非静态类的创建</h2><p>  需要创建一个这样的类,首先需要外部类的引用,然后用.new方法去创建这个外部类的内部类.原因也很简单——因为一个非静态的内部类需要访问外部类的话,需要持有这个外部类的引用，不然不知道访问哪个外部类,代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNew</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DotNew dn = <span class="keyword">new</span> DotNew();</span><br><span class="line">        <span class="comment">//这样内部类就隐式的持有了这个dn的引用</span></span><br><span class="line">        DotNew.Inner dni = dn.new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5185_u90E8_u7C7B_u548C_u5411_u4E0A_u8F6C_u578B"><a href="#u5185_u90E8_u7C7B_u548C_u5411_u4E0A_u8F6C_u578B" class="headerlink" title="内部类和向上转型"></a>内部类和向上转型</h2><p>  在定义一个接口后,我们可以在定义一个private的内部类,去实现这个接口,然后在外部类中去实现一个方法返回这个内部类,但是是以接口的形式去返回,这就能隐藏了这个类的细节.而private的访问权限也让外部不能直接转成这个内部类的形式,就完美的实现了对外暴露接口.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">IDesination</span> <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Destination"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">getDestination</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IDesination();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel4 instance = <span class="keyword">new</span> Parcel4();</span><br><span class="line">        <span class="comment">//对外暴露了接口.</span></span><br><span class="line">        Destination destination = instance.getDestination();</span><br><span class="line">        System.out.println(destination.readLabel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5728_u533F_u540D_u5185_u90E8_u7C7B_u4E2D_u8BBF_u95EE_u5916_u90E8_u7C7B_u4E0D_u9700_u8981final_u7684_u65B9_u6CD5"><a href="#u5728_u533F_u540D_u5185_u90E8_u7C7B_u4E2D_u8BBF_u95EE_u5916_u90E8_u7C7B_u4E0D_u9700_u8981final_u7684_u65B9_u6CD5" class="headerlink" title="在匿名内部类中访问外部类不需要final的方法"></a>在匿名内部类中访问外部类不需要final的方法</h2><p>因为匿名内部类没有名字,故我们不能为其创建一个构造器去初始化这个类,但是我们可以用代码段去初始化匿名内部类,这样就可以实现访问外部类不需要final这个关键字了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base constructor, i = "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Base <span class="title">getBase</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Base(i) &#123;</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">//在这里可以访问外部类非final变量.</span></span><br><span class="line">                System.out.println(<span class="string">"Inside instance initializer"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"In anonymous f()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base = getBase(<span class="number">47</span>);</span><br><span class="line">        base.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span><br><span class="line">Base constructor, i = 47</span><br><span class="line">Inside instance initializer</span><br><span class="line">In anonymous f()</span><br><span class="line">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>
<h2 id="u4E3A_u4EC0_u4E48_u5185_u90E8_u7C7B_u8BBF_u95EE_u7684_u5916_u90E8_u53D8_u91CF_u9700_u8981_u4F7F_u7528final_u4FEE_u9970"><a href="#u4E3A_u4EC0_u4E48_u5185_u90E8_u7C7B_u8BBF_u95EE_u7684_u5916_u90E8_u53D8_u91CF_u9700_u8981_u4F7F_u7528final_u4FEE_u9970" class="headerlink" title="为什么内部类访问的外部变量需要使用final修饰"></a>为什么内部类访问的外部变量需要使用final修饰</h2><blockquote>
<p>  因为生命周期的原因。方法中的局部变量，方法结束后这个变量就要释放掉，final保证这个变量始终指向一个对象。<br>  首先，内部类和外部类其实是处于同一个级别，内部类不会因为定义在方法中就会随着方法的执行完毕而跟随者被销毁。问题就来了，如果外部类的方法中的变量不定义final，那么当外部类方法执行完毕的时候，这个局部变量肯定也就被GC了，然而内部类的某个方法还没有执行完，这个时候他所引用的外部变量已经找不到了。如果定义为final，java会将这个变量复制一份作为成员变量内置于内部类中，这样的话，由于final所修饰的值始终无法改变，所以这个变量所指向的内存区域就不会变。<br> 摘自<a href="http://blog.csdn.net/liushuai_ly/article/details/8197564" target="_blank" rel="external">为什么内部类访问的外部变量需要使用final修饰</a>.</p>
</blockquote>
<h2 id="u63A5_u53E3_u5185_u90E8_u7684_u7C7B"><a href="#u63A5_u53E3_u5185_u90E8_u7684_u7C7B" class="headerlink" title="接口内部的类"></a>接口内部的类</h2><p>  正常情况下,不能在接口内部放置任何代码,但是静态内部类(下文简称嵌套类)却可以成为接口的一部分,因为接口中的任何成员变量都是<code>public</code>和<code>static</code>的,不违反接口的规则,甚至可以在内部实现其外部接口.代码如下:</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Howdy!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Test().howdy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4E3A_u4EC0_u4E48_u9700_u8981_u5185_u90E8_u7C7B"><a href="#u4E3A_u4EC0_u4E48_u9700_u8981_u5185_u90E8_u7C7B" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><p>  TIJ中描述这最吸引人的原因是:</p>
<blockquote>
<p>每个内部类都能独立地继承自一个(接口的)实现,所以无论外围类是否已经继承了某个(接口的)实现.对于内部类都没有影响.  </p>
</blockquote>
<p>  在某种需要下,我们需要某个类继承两个接口,这时候无论是一个类,还是内部类,都可以实现这种功能.但是如果我们需要实现继承两个<strong>抽象的类或者具体的类</strong>的时候,前者就不起作用了.这时候就需要我们使用内部类来实现多重继承的功能.一个简单的例子如下代码所示:</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.crainax.tij.innerclasses;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Crainax on 2016/4/1.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">makeE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> E() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiImplementation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takeD</span><span class="params">(D d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takeE</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Z z = <span class="keyword">new</span> Z();</span><br><span class="line">        z.makeE();</span><br><span class="line">        takeD(z);</span><br><span class="line">        <span class="comment">//实现所需要的多重继承的功能.</span></span><br><span class="line">        takeE(z.makeE());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  使用了内部类不但解决了”多重继承”的问题,还具有以下一些特性:</p>
<ol>
<li>内部类可以有多个实例,每个实例都有自己的状态信息,并且与其外围类对象的信息相互独立.</li>
<li>在单个外围类中,可以让多个内部类以不同的方式实现同一个接口,或继承同一个类.</li>
<li>创建内部类对象的时刻并不依赖于外围类的创建.</li>
<li>内部类并没有令人迷惑的”is-a”关系,它就是一个独立的实体.</li>
</ol>
<h2 id="u547D_u4EE4_u6A21_u5F0F_u4E0E_u5185_u90E8_u7C7B"><a href="#u547D_u4EE4_u6A21_u5F0F_u4E0E_u5185_u90E8_u7C7B" class="headerlink" title="命令模式与内部类"></a>命令模式与内部类</h2><p>  Thinking In Java 对于这里的描述很详细,表现了Java在这里优雅的解决方案,我就在这里概括几点:</p>
<blockquote>
<p> 其中:</p>
<ol>
<li>在事件驱动系统中,也就是在GUI问题中,用到了大量的内部类.</li>
<li>其中分有<code>Event</code>抽象类,定义了事件的时间戳与一些特有的属性,其中有抽象方法 <code>action()</code>;还有<code>Controller</code>的类,能对<code>Event</code>起到一个遍历运行的作用.</li>
<li>一个控制框架的特定实现,比如控制温室的运作,有灯光、水、温度调节器的开关，还有响铃和重新启动系统，每种操作都集成在<code>Controller</code>类中,无疑用命令模式是最好解决的.</li>
<li>但是此时也有了一个问题,就是这个命令需要有<code>action()</code>的实现,又希望能访问到Controller的一些成员变量去控制这个行为.</li>
<li>这时内部类就派上用场了,每个命令都写在<code>Controller</code>中,用内部类继承<code>Event</code>类,就能实现这个功能了.此时再配合上一个队列,就能实现事件的不断触发与执行过程了.</li>
</ol>
</blockquote>
<h2 id="u5185_u90E8_u7C7B_u7684_u7EE7_u627F"><a href="#u5185_u90E8_u7C7B_u7684_u7EE7_u627F" class="headerlink" title="内部类的继承"></a>内部类的继承</h2><p>  因为内部类隐式的持有外部类(下文称A)的引用,所以如果需要另外一个外部类(下文称B)去继承这个内部类的话,那么B也需要这个A的引用,不然不能经过编译,这时候可以在构造器中去说明对A引用的持有:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  ! InheritInner() &#123;&#125; // 不能经过编译</span></span><br><span class="line">    InheritInner(WithInner wi) &#123;</span><br><span class="line">        wi.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WithInner wi = <span class="keyword">new</span> WithInner();</span><br><span class="line">        InheritInner ii = <span class="keyword">new</span> InheritInner(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  当然还有一种情况,即B也有一个内部类,B继承于A,B的内部类继承于A的内部类,此时就不需要说明这个引用的持有.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>以下知识点通过阅读Thinking in Java总结,也是平常不怎么接触到的技巧.</p>
</blockquote>
<h2 id="u5185_u90E8_u975E_u9759_u6001_u7C7B_u7684_u521B_u5EFA">]]>
    </summary>
    
      <category term="Java" scheme="http://crainax.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android收藏开源库汇总]]></title>
    <link href="http://crainax.github.io/2016/03/27/Android/Android%E6%94%B6%E8%97%8F%E5%BC%80%E6%BA%90%E5%BA%93%E6%B1%87%E6%80%BB/"/>
    <id>http://crainax.github.io/2016/03/27/Android/Android收藏开源库汇总/</id>
    <published>2016-03-27T15:47:50.368Z</published>
    <updated>2016-04-19T09:00:55.670Z</updated>
    <content type="html"><![CDATA[<h2 id="SlidingPaneLayout"><a href="#SlidingPaneLayout" class="headerlink" title="SlidingPaneLayout"></a>SlidingPaneLayout</h2><blockquote>
<p>这个库可以用做出像QQ一样的侧滑效果,也有点类似于DrawerLayout.</p>
</blockquote>
<ul>
<li><a href="http://my.oschina.net/summerpxy/blog/211835" target="_blank" rel="external">SlidingPaneLayout的基本使用</a></li>
<li><a href="http://blog.csdn.net/xyz_lmn/article/details/12618149" target="_blank" rel="external">Android UI开发第三十四篇——SlidingPaneLayout</a></li>
</ul>
<h2 id="u7B26_u5408MD_u8BBE_u8BA1_u7684_u5E95_u90E8_u8BBE_u8BA1_u6807_u7B7E_u680F"><a href="#u7B26_u5408MD_u8BBE_u8BA1_u7684_u5E95_u90E8_u8BBE_u8BA1_u6807_u7B7E_u680F" class="headerlink" title="符合MD设计的底部设计标签栏"></a>符合MD设计的底部设计标签栏</h2><blockquote>
<p>一个定制的底部View组件,符合Material Design BottomBar设计规范.</p>
</blockquote>
<ul>
<li><p><a href="https://github.com/roughike/BottomBar" target="_blank" rel="external">roughike/BottomBar</a><br><img src="https://raw.githubusercontent.com/aurelhubert/ahbottomnavigation/master/demo3.gif" alt=""></p>
<blockquote>
<p>一个实现了Material Design底部导航设计规范的库.</p>
</blockquote>
</li>
<li><p><a href="https://github.com/aurelhubert/ahbottomnavigation" target="_blank" rel="external">aurelhubert/ahbottomnavigation</a><br><img src="https://raw.githubusercontent.com/roughike/BottomBar/master/demo2-badge.gif" alt=""></p>
</li>
</ul>
<h2 id="u5BC6_u7801_u8F93_u5165_u6846"><a href="#u5BC6_u7801_u8F93_u5165_u6846" class="headerlink" title="密码输入框"></a>密码输入框</h2><blockquote>
<p>一个符合Material Design设计规范的密码View控件.能通过旁边的小图标来控制密码的可见性.</p>
</blockquote>
<ul>
<li><a href="https://github.com/lisawray/passwordview" target="_blank" rel="external">lisawray/passwordview</a><br><img src="https://raw.githubusercontent.com/lisawray/passwordview/master/2016-3-15.png" alt=""></li>
</ul>
<h2 id="Emoji_u8868_u60C5"><a href="#Emoji_u8868_u60C5" class="headerlink" title="Emoji表情"></a>Emoji表情</h2><blockquote>
<p>一个简单的库,能支持Emoji表情,也能在PopupWindow中选择Emoji表情.内置两个API:EmojiEditText &amp; EmojiTextView.</p>
</blockquote>
<ul>
<li><a href="https://github.com/vanniktech/Emoji" target="_blank" rel="external">vanniktech/Emoji</a><br><img src="https://github.com/vanniktech/Emoji/raw/master/preview_2.png" alt=""></li>
</ul>
<blockquote>
<p>下面这个是渲染默认表情成Emoji表情的库</p>
</blockquote>
<ul>
<li><a href="https://github.com/hani-momanii/SuperNova-Emoji" target="_blank" rel="external">hani-momanii/SuperNova-Emoji</a><br><img src="https://github.com/hani-momanii/SuperNova-Emoji/raw/master/vid.gif" alt=""></li>
</ul>
<h2 id="u66F4_u591A_u7684_u52A8_u753B_u63D2_u503C_u5668"><a href="#u66F4_u591A_u7684_u52A8_u753B_u63D2_u503C_u5668" class="headerlink" title="更多的动画插值器"></a>更多的动画插值器</h2><blockquote>
<p>28个不同的动画插值器,它不同于Android内置的4种插值器。</p>
</blockquote>
<ul>
<li><a href="https://github.com/MasayukiSuda/EasingInterpolator" target="_blank" rel="external">MasayukiSuda/EasingInterpolator</a><br><img src="https://github.com/MasayukiSuda/EasingInterpolator/raw/master/art/FPSAnimator1.gif" alt=""></li>
</ul>
<h2 id="u6DF1_u5165_u8BA2_u5236_u7684_u52A8_u753B"><a href="#u6DF1_u5165_u8BA2_u5236_u7684_u52A8_u753B" class="headerlink" title="深入订制的动画"></a>深入订制的动画</h2><blockquote>
<p>一个简单但强大的库,适用于 Tween / SpriteSheet / ParabolicMotion(抛物线运动) / Android TextureView和SurfaceView。</p>
</blockquote>
<ul>
<li><a href="https://github.com/MasayukiSuda/FPSAnimator" target="_blank" rel="external">MasayukiSuda/FPSAnimator</a><br><img src="https://github.com/MasayukiSuda/FPSAnimator/raw/master/art/parabolicDemo.gif" alt=""><br><img src="https://github.com/MasayukiSuda/FPSAnimator/raw/master/art/spriteSheet.gif" alt=""></li>
</ul>
<h2 id="u663E_u793A_u6B4C_u8BCD_u7684_u63A7_u4EF6"><a href="#u663E_u793A_u6B4C_u8BCD_u7684_u63A7_u4EF6" class="headerlink" title="显示歌词的控件"></a>显示歌词的控件</h2><blockquote>
<p>这个库提供了一个简单的View,接受歌词作为输入,显示歌词,根据时间戳自动显示每个句子,还支持滚动。</p>
</blockquote>
<ul>
<li><a href="https://github.com/markzhai/LyricView" target="_blank" rel="external">markzhai/LyricView</a><br><img src="https://github.com/markzhai/LyricHere/raw/master/art/Screenshot_2015-03-20-17-11-09.jpg" alt=""></li>
</ul>
<h2 id="Loading__u56FE_u5927_u6C47_u603B"><a href="#Loading__u56FE_u5927_u6C47_u603B" class="headerlink" title="Loading 图大汇总"></a>Loading 图大汇总</h2><h3 id="Loading_u52A8_u753B_u6548_u679C_u7684SVG_u56FE"><a href="#Loading_u52A8_u753B_u6548_u679C_u7684SVG_u56FE" class="headerlink" title="Loading动画效果的SVG图"></a>Loading动画效果的SVG图</h3><blockquote>
<p>这两个库能做成带有SVG图特有的线条动画美感效果的Loading效果,每个库也都有其有特色的地方吧!</p>
</blockquote>
<ul>
<li><p><a href="https://github.com/glomadrian/RoadRunner" target="_blank" rel="external">glomadrian/RoadRunner</a><br><img src="https://github.com/glomadrian/RoadRunner/raw/master/art/materialTwitter.gif" alt=""></p>
</li>
<li><p><a href="https://github.com/JorgeCastilloPrz/AndroidFillableLoaders" target="_blank" rel="external">JorgeCastilloPrz/AndroidFillableLoaders</a><br><img src="https://github.com/JorgeCastilloPrz/AndroidFillableLoaders/raw/master/art/demoWaves.gif" alt=""></p>
</li>
</ul>
<blockquote>
<p>令附上制作成SVG路径工具<strong>GIMP</strong>使用说明: <a href="http://www.useragentman.com/blog/2013/04/26/how-to-create-svg-paths-easily-using-the-gimp/" target="_blank" rel="external">点击查看教程</a></p>
</blockquote>
<h3 id="SpinKit_u98CE_u683C_u7684Loading_u753B_u9762"><a href="#SpinKit_u98CE_u683C_u7684Loading_u753B_u9762" class="headerlink" title="SpinKit风格的Loading画面"></a>SpinKit风格的Loading画面</h3><blockquote>
<p>加载动画.</p>
</blockquote>
<ul>
<li><a href="https://github.com/ybq/Android-SpinKit" target="_blank" rel="external">ybq/Android-SpinKit</a><br><img src="https://raw.githubusercontent.com/ybq/AndroidSpinKit/master/art/screen.gif" alt=""><br><img src="https://raw.githubusercontent.com/ybq/AndroidSpinKit/master/art/screen2.gif" alt=""></li>
</ul>
<h3 id="u5F88_u8D5E_u7684_u5C0F_u732BLoadingView"><a href="#u5F88_u8D5E_u7684_u5C0F_u732BLoadingView" class="headerlink" title="很赞的小猫LoadingView"></a>很赞的小猫LoadingView</h3><blockquote>
<p>包含着一只非常可爱的小猫的Loading画面,十分的卡哇伊</p>
</blockquote>
<ul>
<li><a href="https://github.com/Rogero0o/CatLoadingView" target="_blank" rel="external">Rogero0o/CatLoadingView</a><br><img src="https://camo.githubusercontent.com/762015246e027b7d46df51faa51fd669e44f974b/687474703a2f2f7777342e73696e61696d672e636e2f6d773639302f61363935616364656a7731663268626d66787a6b3567323038753061326173732e676966" alt=""></li>
</ul>
<h2 id="u86C7_u578B_u83DC_u5355_u680F"><a href="#u86C7_u578B_u83DC_u5355_u680F" class="headerlink" title="蛇型菜单栏"></a>蛇型菜单栏</h2><blockquote>
<p>模仿Tumblr’s菜单栏效果,拖动起来看起来像一条蛇,看起来特别酷炫.</p>
</blockquote>
<ul>
<li><a href="https://github.com/xmuSistone/android-snake-menu" target="_blank" rel="external">xmuSistone/android-snake-menu</a><br><img src="https://github.com/xmuSistone/android-snake-menu/raw/master/capture2.gif" alt=""></li>
</ul>
<blockquote>
<p>除了蛇型拖动效果,还有点击时Expand的效果.</p>
</blockquote>
<ul>
<li><a href="https://github.com/tiancaiCC/SpringFloatingActionMenu" target="_blank" rel="external">tiancaiCC/SpringFloatingActionMenu</a><br><img src="https://raw.githubusercontent.com/tiancaiCC/SpringFloatingActionMenu/master/art/demo.gif" alt=""></li>
</ul>
<h2 id="u56FE_u7247_u8F6E_u8BE2_u64AD_u653E"><a href="#u56FE_u7247_u8F6E_u8BE2_u64AD_u653E" class="headerlink" title="图片轮询播放"></a>图片轮询播放</h2><blockquote>
<p>在APP中很常见,一个简单但是也很灵活的库,用于在你的应用中添加循环播放的View.</p>
</blockquote>
<ul>
<li><a href="https://github.com/sayyam/carouselview" target="_blank" rel="external">sayyam/carouselview</a><br><img src="https://github.com/sayyam/carouselview/raw/master/sample/src/main/assets/carousel_gif.gif" alt=""></li>
</ul>
<h2 id="u5E26_u52A8_u753B_u7684EditText"><a href="#u5E26_u52A8_u753B_u7684EditText" class="headerlink" title="带动画的EditText"></a>带动画的EditText</h2><blockquote>
<p>在EditText中输入文本的时候,文本进入带有一定的动画效果</p>
</blockquote>
<ul>
<li><a href="https://github.com/alphamu/AnimatedEditText" target="_blank" rel="external">alphamu/AnimatedEditText</a><br><img src="https://camo.githubusercontent.com/39dd2b000b65eca4afb3fa6f7dfb3262ac230ebe/687474703a2f2f692e67697068792e636f6d2f4e7a643338513537434a357a712e676966" alt=""></li>
</ul>
<h2 id="u6BDB_u73BB_u7483_u9501_u5C4F_u754C_u9762"><a href="#u6BDB_u73BB_u7483_u9501_u5C4F_u754C_u9762" class="headerlink" title="毛玻璃锁屏界面"></a>毛玻璃锁屏界面</h2><blockquote>
<p>背景是毛玻璃的锁屏View,也能轻松去定制其中的效果.</p>
</blockquote>
<ul>
<li><a href="https://github.com/Nightonke/BlurLockView" target="_blank" rel="external">Nightonke/BlurLockView</a><br><img src="https://github.com/Nightonke/BlurLockView/raw/master/Pictures/in_out.gif" alt=""></li>
</ul>
<h2 id="u76D1_u63A7_u8F6F_u952E_u76D8_u5F00_u542F_u4E0E_u5426"><a href="#u76D1_u63A7_u8F6F_u952E_u76D8_u5F00_u542F_u4E0E_u5426" class="headerlink" title="监控软键盘开启与否"></a>监控软键盘开启与否</h2><blockquote>
<p>　　能监视Android软件键盘打开/关闭时的时刻 – Android SDK不提供直接的方式来跟踪打开/关闭软键盘的事件。这个库能提供这种方法。</p>
</blockquote>
<ul>
<li><a href="https://github.com/AzimoLabs/AndroidKeyboardWatcher" target="_blank" rel="external">AzimoLabs/AndroidKeyboardWatcher</a><br><img src="https://raw.githubusercontent.com/AzimoLabs/AndroidKeyboardWatcher/master/art/keyboard_shown.png" alt=""></li>
</ul>
<blockquote>
<p>提供类似微信的键盘设计方案,防冲突.</p>
</blockquote>
<ul>
<li><a href="https://github.com/Jacksgong/JKeyboardPanelSwitch" target="_blank" rel="external">Jacksgong/JKeyboardPanelSwitch</a><br><img src="https://raw.githubusercontent.com/Jacksgong/JKeybordPanelSwitch/master/art/non-fullscreen_resolved.gif" alt=""></li>
</ul>
<h2 id="Android_u8DEF_u7531_u6846_u67B6"><a href="#Android_u8DEF_u7531_u6846_u67B6" class="headerlink" title="Android路由框架"></a>Android路由框架</h2><blockquote>
<p>一个在框架层去映射URL成对应的Activity或者相应的Actions.</p>
</blockquote>
<ul>
<li><a href="https://github.com/campusappcn/AndRouter" target="_blank" rel="external">campusappcn/AndRouter</a></li>
</ul>
<h2 id="u80FD_u8BA9_u83DC_u5355_u680F_u77AC_u95F4_u7206_u70B8_u7684_u5E93"><a href="#u80FD_u8BA9_u83DC_u5355_u680F_u77AC_u95F4_u7206_u70B8_u7684_u5E93" class="headerlink" title="能让菜单栏瞬间爆炸的库"></a>能让菜单栏瞬间爆炸的库</h2><blockquote>
<p>在菜单栏或者在FAB中大作文章的库~</p>
</blockquote>
<ul>
<li><a href="https://github.com/Nightonke/BoomMenu" target="_blank" rel="external">Nightonke/BoomMenu</a><br><img src="https://github.com/Nightonke/BoomMenu/raw/master/Pictures/show_circle.gif?raw=true" alt=""><br><img src="https://github.com/Nightonke/BoomMenu/raw/master/Pictures/show_ham.gif?raw=true" alt=""></li>
</ul>
<h2 id="u83B7_u53D6_u7535_u8BDD_u4FE1_u606F"><a href="#u83B7_u53D6_u7535_u8BDD_u4FE1_u606F" class="headerlink" title="获取电话信息"></a>获取电话信息</h2><blockquote>
<p>一个获取号码归属地和其他信息（诈骗、骚扰等）的开源库。支持本地离线（含归属地、骚扰、常用号码）和网络（百度、聚合数据或自定义 API）查询。</p>
</blockquote>
<ul>
<li><a href="https://github.com/xdtianyu/PhoneNumber" target="_blank" rel="external">xdtianyu/PhoneNumber</a></li>
</ul>
<h2 id="u4EFFYoutube_u6807_u7B7E_u680F"><a href="#u4EFFYoutube_u6807_u7B7E_u680F" class="headerlink" title="仿Youtube标签栏"></a>仿Youtube标签栏</h2><ul>
<li><a href="https://github.com/saiff35/LivingTabs" target="_blank" rel="external">saiff35/LivingTabs</a><br><img src="https://github.com/saiff35/LivingTabs/raw/master/art/demo.gif" alt=""></li>
</ul>
<h2 id="u4E09_u89D2_u6807_u7B7EView"><a href="#u4E09_u89D2_u6807_u7B7EView" class="headerlink" title="三角标签View"></a>三角标签View</h2><blockquote>
<p>可以实现给某个View中加上三角型的hint效果的小标签.</p>
</blockquote>
<ul>
<li><a href="https://github.com/shts/TriangleLabelView" target="_blank" rel="external">shts/TriangleLabelView</a><br><img src="https://github.com/shts/TriangleLabelView/raw/master/img/capture.png" alt=""></li>
</ul>
<h2 id="Google_u67B6_u6784_u5B98_u65B9_u9879_u76EE"><a href="#Google_u67B6_u6784_u5B98_u65B9_u9879_u76EE" class="headerlink" title="Google架构官方项目"></a>Google架构官方项目</h2><blockquote>
<p>收集了很多Android项目用于讨论和展示不同的架构模式。</p>
</blockquote>
<ul>
<li><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">googlesamples/android-architecture</a><br><img src="https://github.com/googlesamples/android-architecture/wiki/images/tasks2.png" alt=""></li>
</ul>
<h2 id="u5FEB_u901F_u5F00_u53D1_u96C6_u6210_u6846_u67B6"><a href="#u5FEB_u901F_u5F00_u53D1_u96C6_u6210_u6846_u67B6" class="headerlink" title="快速开发集成框架"></a>快速开发集成框架</h2><blockquote>
<p>一个小,但功能齐全的框架,让你更快地去构建Android项目.</p>
<ul>
<li><a href="https://github.com/bluelinelabs/Conductor" target="_blank" rel="external">bluelinelabs/Conductor</a></li>
</ul>
</blockquote>
<h2 id="u70AB_u9177_u7684_u5F15_u5BFC_u754C_u9762_u5FEB_u901F_u5F00_u53D1"><a href="#u70AB_u9177_u7684_u5F15_u5BFC_u754C_u9762_u5FEB_u901F_u5F00_u53D1" class="headerlink" title="炫酷的引导界面快速开发"></a>炫酷的引导界面快速开发</h2><blockquote>
<p>Welcome Coordinator是一个Android的库,用于帮助你创造无与伦比的欢迎界面,你也可以使用这个库来定制炫酷的向导。看看如何集成到你的应用程序!</p>
</blockquote>
<ul>
<li><a href="https://github.com/txusballesteros/welcome-coordinator" target="_blank" rel="external">txusballesteros/welcome-coordinator</a><br><img src="https://github.com/txusballesteros/welcome-coordinator/raw/master/assets/welcome_demo.gif" alt=""><br><img src="https://github.com/txusballesteros/welcome-coordinator/raw/master/assets/onboarding_demo.gif" alt=""></li>
</ul>
<h2 id="RxJava_+_BLE"><a href="#RxJava_+_BLE" class="headerlink" title="RxJava + BLE"></a>RxJava + BLE</h2><blockquote>
<p>RxAndroidBle是一个强大的库,用于解决Android的蓝牙低能耗的问题,由RxJava提供支持.</p>
</blockquote>
<ul>
<li><a href="https://github.com/Polidea/RxAndroidBle" target="_blank" rel="external">Polidea/RxAndroidBle</a>  </li>
</ul>
<h2 id="u900F_u660E_u72B6_u6001_u680F_u4E13_u7528_u8F6E_u5B50"><a href="#u900F_u660E_u72B6_u6001_u680F_u4E13_u7528_u8F6E_u5B50" class="headerlink" title="透明状态栏专用轮子"></a>透明状态栏专用轮子</h2><blockquote>
<p>方便实现Android APP沉浸式状态栏解决方案,还能设置透明度,整理成一个工具类，方便需要的开发者。</p>
</blockquote>
<ul>
<li><a href="https://github.com/laobie/StatusBarUtil" target="_blank" rel="external">laobie/StatusBarUtil</a>(注意下图中的状态栏)<br><img src="https://github.com/laobie/StatusBarUtil/raw/master/img/set_color_for_drawer_layout.png" alt=""></li>
</ul>
<h2 id="FPS_u4FA6_u63A2"><a href="#FPS_u4FA6_u63A2" class="headerlink" title="FPS侦探"></a>FPS侦探</h2><blockquote>
<p>一个能显示当前FPS的库.</p>
</blockquote>
<ul>
<li><a href="https://github.com/wasabeef/Takt" target="_blank" rel="external">wasabeef/Takt</a><br><img src="https://github.com/wasabeef/Takt/raw/master/art/takt.gif" alt=""></li>
</ul>
<h2 id="u5728_u9876_u90E8_u751F_u6210_u7684SnackBar"><a href="#u5728_u9876_u90E8_u751F_u6210_u7684SnackBar" class="headerlink" title="在顶部生成的SnackBar"></a>在顶部生成的SnackBar</h2><blockquote>
<p>在顶部,Toolbar的下方生成一个SnackBar,用以显示信息.</p>
</blockquote>
<ul>
<li><a href="https://github.com/AndreiD/TSnackBar" target="_blank" rel="external">AndreiD/TSnackBar</a><br><img src="https://raw.githubusercontent.com/AndreiD/TSnackBar/master/app/snackbar.gif" alt=""></li>
</ul>
<h2 id="u901A_u8FC7URL_u6765_u5728Activity_u4E2D_u53BB_u8DEF_u7531"><a href="#u901A_u8FC7URL_u6765_u5728Activity_u4E2D_u53BB_u8DEF_u7531" class="headerlink" title="通过URL来在Activity中去路由"></a>通过URL来在Activity中去路由</h2><blockquote>
<p>Android路由器.</p>
</blockquote>
<ul>
<li><a href="https://github.com/mzule/ActivityRouter" target="_blank" rel="external">mzule/ActivityRouter</a><br><img src="https://raw.githubusercontent.com/mzule/ActivityRouter/master/gif/router.gif" alt=""></li>
</ul>
<h2 id="u98CE_u9A9A_u7684_u6570_u5B57_u53D8_u5F62View"><a href="#u98CE_u9A9A_u7684_u6570_u5B57_u53D8_u5F62View" class="headerlink" title="风骚的数字变形View"></a>风骚的数字变形View</h2><blockquote>
<p>一个能显示9个数字,展示那些具有风骚动画的数字.</p>
</blockquote>
<ul>
<li><a href="https://github.com/me-abhinav/NumberMorphView" target="_blank" rel="external">me-abhinav/NumberMorphView</a><br><img src="https://raw.githubusercontent.com/me-abhinav/NumberMorphView/dev/sample.gif" alt=""></li>
</ul>
<h2 id="u652F_u6301_u591A_u6807_u9898_u7684CollapsingToolbar"><a href="#u652F_u6301_u591A_u6807_u9898_u7684CollapsingToolbar" class="headerlink" title="支持多标题的CollapsingToolbar"></a>支持多标题的CollapsingToolbar</h2><blockquote>
<p>在展开状态下,这个库能代替官方的CollapsingToolbarLayout,最多能显示3行的标题,当折叠时,底下的标题会慢慢消逝,只留最上面的到标题栏中.</p>
</blockquote>
<ul>
<li><a href="https://github.com/opacapp/multiline-collapsingtoolbar" target="_blank" rel="external">opacapp/multiline-collapsingtoolbar</a><br><img src="https://camo.githubusercontent.com/ca1ca0260867c48bd090d20f0ec30ef8f954b267/68747470733a2f2f64726f702e72616d692e696f2f304479454e2f" alt=""></li>
</ul>
<h2 id="u5F69_u8272_u7684_u5BFC_u822A_u680F"><a href="#u5F69_u8272_u7684_u5BFC_u822A_u680F" class="headerlink" title="彩色的导航栏"></a>彩色的导航栏</h2><blockquote>
<p>彩色的导航栏</p>
</blockquote>
<ul>
<li><a href="https://github.com/DevLight-Mobile-Agency/NavigationTabBar" target="_blank" rel="external">DevLight-Mobile-Agency/NavigationTabBar</a><br><img src="https://camo.githubusercontent.com/34b7f502917712a202586065cb638d30a57323a1/68747470733a2f2f6c68352e676f6f676c6575736572636f6e74656e742e636f6d2f2d686d454c665a51766578552f567670566c6f6f615076492f41414141414141414350412f3548413569633764415377425559717071636678416d664c7a50504458656a71512f773332322d683535322d6e6f2f6e7462732e676966" alt=""></li>
</ul>
<h2 id="Kotlin_u5FEB_u901F_u5F00_u53D1UI_u6846_u67B6"><a href="#Kotlin_u5FEB_u901F_u5F00_u53D1UI_u6846_u67B6" class="headerlink" title="Kotlin快速开发UI框架"></a>Kotlin快速开发UI框架</h2><blockquote>
<p>灵感从React.js而来</p>
</blockquote>
<ul>
<li><a href="https://github.com/maannajjar/lattekit" target="_blank" rel="external">maannajjar/lattekit</a><br><img src="https://camo.githubusercontent.com/9073bcf6e42233ecdc4d4ecd464bb231c0d33ac7/68747470733a2f2f696d6775722e636f6d2f4a734e6a65314c2e676966" alt=""></li>
</ul>
<h2 id="u8D70_u52BF_u56FE_u5927_u6CD5_u597D"><a href="#u8D70_u52BF_u56FE_u5927_u6CD5_u597D" class="headerlink" title="走势图大法好"></a>走势图大法好</h2><blockquote>
<p>一个简单的Android图表线性走势图自定义View.  </p>
</blockquote>
<ul>
<li><a href="https://github.com/robinhoodmarkets/spark" target="_blank" rel="external">robinhoodmarkets/spark</a><br><img src="https://github.com/robinhoodmarkets/spark/blob/master/images/sample.png" alt="">  </li>
</ul>
<h2 id="u6298_u53E0_u5F62_u6001_u7684_u5361_u7247"><a href="#u6298_u53E0_u5F62_u6001_u7684_u5361_u7247" class="headerlink" title="折叠形态的卡片"></a>折叠形态的卡片</h2><blockquote>
<p>像是一层层卡片堆叠在一起一样,无论是展开还是折叠,都具有十分漂亮的动画效果.</p>
</blockquote>
<ul>
<li><a href="https://github.com/Ramotion/folding-cell-android" target="_blank" rel="external">Ramotion/folding-cell-android</a><br><img src="https://github.com/Ramotion/folding-cell-android/blob/master/folding_cell_preview.gif" alt=""></li>
</ul>
<h2 id="u7B26_u5408Material_Design_u7684_u65E5_u5386View"><a href="#u7B26_u5408Material_Design_u7684_u65E5_u5386View" class="headerlink" title="符合Material Design的日历View"></a>符合Material Design的日历View</h2><blockquote>
<p>符合Material Design的日历View</p>
</blockquote>
<ul>
<li><a href="https://github.com/SundeepK/CompactCalendarView" target="_blank" rel="external">SundeepK/CompactCalendarView</a></li>
</ul>
<hr>
<h1 id="Android__u5B9E_u7528_u5DE5_u5177"><a href="#Android__u5B9E_u7528_u5DE5_u5177" class="headerlink" title="Android 实用工具"></a>Android 实用工具</h1><h2 id="TinyPng"><a href="#TinyPng" class="headerlink" title="TinyPng"></a><a href="https://tinypng.com" target="_blank" rel="external">TinyPng</a></h2><p>TinyPng 是一个图片压缩工具，可能有些人感觉这个工具应该给设计师使用，我觉得也是。不过有些时候，设计师给你出了个1920* 1080 的启动页，一张图片，1M 左右，我也是泪奔了，感觉设计师说话的时间，估计我们都压缩完了，自己动手，丰衣足食。而且它还提供了API，对不同语言都还有提供了插件，比如Java 就提供了Maven 的支持。<br><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-4-8/92524287.jpg" alt=""></p>
<h2 id="Json2POJO"><a href="#Json2POJO" class="headerlink" title="Json2POJO"></a><a href="http://www.jsonschema2pojo.org/" target="_blank" rel="external">Json2POJO</a></h2><p>Json2POJO 是可以将一个Json 字符串转换成Java 的POJO 类的网页工具，而且可以选择转换器，比如我们使用Retrofit 可以选择Jackson，Gson，而且可以选择重写get，set 方法，还有hashcode，equals 和toString 方法，可以省去了不少手写的时间。<br><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-4-8/37794704.jpg" alt=""></p>
<h2 id="dryrun"><a href="#dryrun" class="headerlink" title="dryrun"></a><a href="https://github.com/cesarferreira/dryrun" target="_blank" rel="external">dryrun</a></h2><p>一个命令行,马上把Github上的测试用例发布到手机上进行调试.<br><img src="https://raw.githubusercontent.com/cesarferreira/dryrun/master/extras/usage_v4.gif" alt=""></p>
<h2 id="Android_Material_Design_Icon_Generator"><a href="#Android_Material_Design_Icon_Generator" class="headerlink" title="Android Material Design Icon Generator"></a><a href="http://bitdroid.de/Android-Material-Icon-Generator/" target="_blank" rel="external">Android Material Design Icon Generator</a></h2><p>创建符合Android Material Design设计规范的图标, 带有十分赞的阴影哦!<br><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-4-15/97827189.jpg" alt=""></p>
<h2 id="facebook/redex"><a href="#facebook/redex" class="headerlink" title="facebook/redex"></a><a href="https://github.com/facebook/redex" target="_blank" rel="external">facebook/redex</a></h2><p>FaceBook出品的一款工具,能对Android的应用进行字节码优化,优化的能力十分强大!<br>![]</p>
<h2 id="carlospaulino/parrot"><a href="#carlospaulino/parrot" class="headerlink" title="carlospaulino/parrot"></a><a href="https://github.com/carlospaulino/parrot" target="_blank" rel="external">carlospaulino/parrot</a></h2><p>一个Gradle插件,能自动把项目中的字符串资源转换成多国的语言.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="SlidingPaneLayout"><a href="#SlidingPaneLayout" class="headerlink" title="SlidingPaneLayout"></a>SlidingPaneLayout</h2><blockquote>
]]>
    </summary>
    
      <category term="android" scheme="http://crainax.github.io/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java小技巧汇总]]></title>
    <link href="http://crainax.github.io/2016/03/27/Java/Java%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/"/>
    <id>http://crainax.github.io/2016/03/27/Java/Java小技巧汇总/</id>
    <published>2016-03-27T08:24:24.441Z</published>
    <updated>2016-04-19T09:43:09.644Z</updated>
    <content type="html"><![CDATA[<p>这篇博文主要用于记录一些没见过的小tips~</p>
<ol>
<li><p>在<code>Intellij IDEA</code>中打开<code>assert</code>关键字调试,应该在 Run-&gt;Run Configurations-&gt;VM Options中填写<code>&quot;-ea&quot;</code>,如下图<br><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-3-27/94499851.jpg" alt=""></p>
</li>
<li><p>注意对新类编写<code>hashCode()</code>的方法,在<code>HashMap</code>每个键都是以散列码,也就是这个方法生成的数为主,而不是通过<code>equals()</code>方法去判断两个键是否相同.只不过默认时候<code>hashCode()</code>是返回当前对象的地址值,而<code>equals()</code>默认时候也是判断两个对象的地址值是否相等.我们可以使用IDEA快速生成这两个方法.<br><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-4-3/24688916.jpg" alt=""><br>测试代码地址:<a href="https://github.com/Crainax/DemoCode/blob/master/Java/JavaTips/HashTest.java" target="_blank" rel="external">点击进入</a></p>
</li>
<li><p>在<code>Intellij IDEA</code>中,TODO注释能提醒自己要完成什么事情,或者在某个时候有了灵感,防止后面忘记了,都可以用todo注释去提醒自己<br><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-4-19/36324178.jpg" alt=""></p>
</li>
<li><p>在<code>Intellij IDEA</code>中,我们能使用File Header功能,来自动生成我们的类的头的自定义描述及格式:<br><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-4-19/83122808.jpg" alt=""><br>以下是本人的代码:</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* Project: $&#123;PROJECT_NAME&#125; &lt;br/&gt;</span><br><span class="line">* Package: $&#123;PACKAGE_NAME&#125; &lt;br/&gt;  </span><br><span class="line">* Description: &lt;br/&gt;</span><br><span class="line">* &lt;hr/&gt;</span><br><span class="line">* @author $&#123;USER&#125; &lt;br/&gt;</span><br><span class="line">* @since $&#123;DATE&#125; &lt;br/&gt;</span><br><span class="line">* @version 1.0 &lt;br/&gt;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇博文主要用于记录一些没见过的小tips~</p>
<ol>
<li><p>在<code>Intellij IDEA</code>中打开<code>assert</code>关键字调试,应该在 Run-&gt;Run Configurations-&gt;VM Optio]]>
    </summary>
    
      <category term="Java" scheme="http://crainax.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线索二叉树的建立与遍历C语言实现过程详解]]></title>
    <link href="http://crainax.github.io/2016/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86/"/>
    <id>http://crainax.github.io/2016/03/02/数据结构/线索二叉树的建立与遍历/</id>
    <published>2016-03-02T10:39:23.820Z</published>
    <updated>2016-03-23T09:57:18.770Z</updated>
    <content type="html"><![CDATA[<h1 id="u7EBF_u7D22_u4E8C_u53C9_u6811"><a href="#u7EBF_u7D22_u4E8C_u53C9_u6811" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><h3 id="1-__u5B9A_u4E49"><a href="#1-__u5B9A_u4E49" class="headerlink" title="1.  定义"></a>1.  定义</h3><p>  n个结点有n-1个前驱和n-1个后继；一共有2n个链域，其中：n+1个空链域，n-1个指针域；因此, 可以用空链域来存放结点的前驱和后继。线索二叉树就是利用n+1个空链域来存放结点的前驱和后继结点的信息。<br><strong>用一张简单的图来了解一下线索二叉树与基本的二叉树的区别吧:</strong><br><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-3-23/49384488.jpg" alt=""></p>
<p>普通二叉树(图1)</p>
<p><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-3-2/69724597.jpg" alt=""></p>
<p>线索二叉树(图2)</p>
<p>  我们可以很清楚的看出,线索二叉树很好的利用了图1中的空指针的空间,使得这些指针能指向以中序遍历二叉树的方式的前驱与后继.不但解决二叉链表找左、右孩子困难的问题，也解决了无法在某个结点中直接找到该结点的前驱与后继的问题。</p>
<h3 id="2-__u7ED3_u70B9_u7ED3_u6784"><a href="#2-__u7ED3_u70B9_u7ED3_u6784" class="headerlink" title="2.  结点结构"></a>2.  结点结构</h3><p><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-3-2/5375677.jpg" alt=""><br>线索二叉树有5个域，比一般的二叉树要多出两个标志位的域：<br>Data域:存放数据的数据域<br>RChild域:指向右子结点(或后继结点)的指针<br>LChild域:指向左子结点(或前驱结点)的指针<br>RTag域:是一个标志域.当该域为0时,RChild是指向右子结点的指针.当该域为1时,则RChild是指向后继结点的指针.<br>LTag域:是一个标志域.当该域为0时,LChild是指向左子结点的指针.当该域为1时,则LChild是指向后继结点的指针.</p>
<p>头结点: 图中的Head结点.<br>根结点: 图中的A结点(二叉树的根结点).</p>
<h3 id="3-_u4E8C_u53C9_u6811_u7684_u7EBF_u7D22_u5316"><a href="#3-_u4E8C_u53C9_u6811_u7684_u7EBF_u7D22_u5316" class="headerlink" title="3.二叉树的线索化"></a>3.二叉树的线索化</h3><p>  有效利用二叉链表中空的存储空间,指定原有的孩子指针为空的域来存放指向前驱和后继的过程,称为线索化.</p>
<p>  简单点说:将二叉树变为线索二叉树的过程也就称为线索化.</p>
<h3 id="4-_u7EBF_u7D22_u4E8C_u53C9_u6811_u7684_u5B58_u50A8_u7ED3_u6784"><a href="#4-_u7EBF_u7D22_u4E8C_u53C9_u6811_u7684_u5B58_u50A8_u7ED3_u6784" class="headerlink" title="4.线索二叉树的存储结构"></a>4.线索二叉树的存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索二叉树中的数据域的存储类型,使用宏定义能实现一改全改的效果</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举类型,代表着标志域指示的指针域指向的是子结点还是前驱后继结点,能更加方便直观的看懂代码</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    Link, Thread</span><br><span class="line">&#125; PointerTag;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结点的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> BiThrNode &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> BiThrNode * lchild, * rchild;</span><br><span class="line">    PointerTag ltag, rtag;</span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure>
<h3 id="5-_u7EBF_u7D22_u4E8C_u53C9_u6811_u7684_u4E2D_u5E8F_u9012_u5F52_u7EBF_u7D22_u5316_u8FC7_u7A0B"><a href="#5-_u7EBF_u7D22_u4E8C_u53C9_u6811_u7684_u4E2D_u5E8F_u9012_u5F52_u7EBF_u7D22_u5316_u8FC7_u7A0B" class="headerlink" title="5.线索二叉树的中序递归线索化过程"></a>5.线索二叉树的中序递归线索化过程</h3><p>  线索化过程看起来挺复杂,但是经过下面几个步骤的分解也就看起来不是那么的难啦~</p>
<ol>
<li><p>以前序创建普通二叉树的方式创建一个未初始化的线索二叉树,以递归的形式去创建,其中当输入的字符为’ ‘时,代表该树没有孩子结点.代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序递归创建一个未线索化的二叉树</span></span><br><span class="line"><span class="comment">//参数: tree 线索二叉树的根结点指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBiThrTree</span><span class="params">(BiThrTree * tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">' '</span> == c) &#123; <span class="comment">//若输入的是空格,则不创建该结点,使得递归可以结束</span></span><br><span class="line">        * tree = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        * tree = ((BiThrTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode)));</span><br><span class="line">        <span class="comment">//设置其数据域</span></span><br><span class="line">        (* tree)-&gt;data = c;</span><br><span class="line">        <span class="comment">//未线索化的过程</span></span><br><span class="line">        (* tree)-&gt;ltag = Link;</span><br><span class="line">        (* tree)-&gt;rtag = Link;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归生成其左子结点</span></span><br><span class="line">        createBiThrTree(&amp;(* tree)-&gt;lchild);</span><br><span class="line">        <span class="comment">//递归生成其右子结点</span></span><br><span class="line">        createBiThrTree(&amp;(* tree)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个全局BiThrNode* 类型的指针变量pre(顾名思义就是上一个创建出来的结点),用于在递归生成结点的时候,记录上次的结点用于让生成的结点的前驱指针指向前驱的结点,然后再通过判断,若该pre结点rchild指针没有所指向,让其指向后继的结点(就是刚刚生成的结点).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BiThrNode *pre = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>增设一个头结点，令其lchild指向二叉树的根结点，ltag=0、rtag=1；并将该结点作为遍历访问的第一个结点的前驱和最后一个结点的后继；最后用头指针指示该头结点。其rchild域的指针指向中序遍历时访问的最后一个结点；反之，令二叉树中序序列中的第一个结点的lchild域指针和最后一个结点rchild域的指针均指向头结点，这好比为二叉树建立了一个双向线索链表，既可以从第一个结点起顺后继进行遍历，也可以从最后一个结点起顺前驱进行遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建头结点.</span></span><br><span class="line"><span class="comment">//参数: head 作为指向头结点的结点指针变量, tree 线索二叉树的根结点指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrderThreading</span><span class="params">(BiThrTree * head, BiThrTree tree)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建头结点</span></span><br><span class="line">    * head = (BiThrTree) malloc(sizeof(BiThrNode));</span><br><span class="line">    <span class="comment">//设置该头结点的左右标志位分别为非线索与线索</span></span><br><span class="line">    <span class="comment">//递归线索化的过程能使得第一个结点的前驱正确指向该头结点.</span></span><br><span class="line">    (* head)-&gt;ltag = Link;  </span><br><span class="line">    (* head)-&gt;rtag = Thread;</span><br><span class="line">    <span class="keyword">if</span> (!tree) &#123;</span><br><span class="line">        <span class="comment">//若根结点不存在,则该二叉树为空,让该头结点指向自身.</span></span><br><span class="line">        (* head)-&gt;lchild = * head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//令头结点的左指针指向根结点</span></span><br><span class="line">        (* head)-&gt;lchild = tree;</span><br><span class="line">        pre = * head;</span><br><span class="line">        <span class="comment">//开始递归输入线索化</span></span><br><span class="line">        inThreading(tree);</span><br><span class="line">        <span class="comment">//此时结束了最后一个结点的线索化了,下面的代码把头结点的后继指向了最后一个结点.</span></span><br><span class="line">        <span class="comment">//并把最后一个结点的后继也指向头结点,此时树成为了一个类似链表的循环.</span></span><br><span class="line">        pre-&gt;rchild = * head;</span><br><span class="line">        pre-&gt;rtag = Thread;</span><br><span class="line">        (* head)-&gt;rchild = pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上述代码即如下图所示的红线内的建立头结点的过程.<br><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-3-6/33263186.jpg" alt=""></p>
<ol>
<li>补全inThreading函数,使得其依次中序递归线索化子结点,此过程就是上图中红线之外的部分.<br>代码如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历线索化</span></span><br><span class="line"><span class="comment">//参数: tree 线索二叉树的根结点指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inThreading</span><span class="params">(BiThrTree tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree) &#123;</span><br><span class="line"></span><br><span class="line">        inThreading(tree-&gt;lchild); <span class="comment">//递归左孩子线索化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历处理内容</span></span><br><span class="line">        <span class="keyword">if</span> (!tree-&gt;lchild) &#123; <span class="comment">//如果该结点没有左孩子,设置ltag为Thread,并把lChild指向前驱结点</span></span><br><span class="line">            tree-&gt;ltag = Thread;</span><br><span class="line">            tree-&gt;lchild = pre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pre-&gt;rchild) &#123;<span class="comment">//处理pre结点(也就是上一个创建的结点),若其无右孩子,则令pre的rChild指向后继结点</span></span><br><span class="line">            pre-&gt;rtag = Thread;</span><br><span class="line">            pre-&gt;rchild = tree;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre = tree;<span class="comment">//令pre全局变量指向已经处理完毕的结点,令下个结点继续处理</span></span><br><span class="line">        <span class="comment">//中序遍历处理结束</span></span><br><span class="line"></span><br><span class="line">        inThreading(tree-&gt;rchild);<span class="comment">//递归右孩子线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p><strong>经过上面几个并不是很长的代码,我们就把新建的二叉树给线索化啦~<br>如果感觉并不能很好地了解上面的描述,可以在纸上去一步步地去演算整个递归过程~</strong></p>
<h3 id="6-_u8FED_u4EE3_u7684_u5F62_u5F0F_u53BB_u4E2D_u5E8F_u904D_u5386_u8BE5_u7EBF_u7D22_u4E8C_u53C9_u6811"><a href="#6-_u8FED_u4EE3_u7684_u5F62_u5F0F_u53BB_u4E2D_u5E8F_u904D_u5386_u8BE5_u7EBF_u7D22_u4E8C_u53C9_u6811" class="headerlink" title="6.迭代的形式去中序遍历该线索二叉树"></a>6.迭代的形式去中序遍历该线索二叉树</h3><p>  相信大家看到线索二叉树的存储结构也差不多知道怎么利用两个标签位去遍历整个线索二叉树了吧,下面就是代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以迭代的形式去中序遍历线索二叉树.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inOrderTraverseThr</span><span class="params">(BiThrTree T)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BiThrTree p = T-&gt;lchild;    <span class="comment">//令p先指向根节点.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出循环的条件是p重新指回了头结点.</span></span><br><span class="line">    <span class="keyword">while</span> (p != T) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;ltag == Link)</span><br><span class="line">            p = p-&gt;lchild;  <span class="comment">//迭代令p指向左子树为空的结点.</span></span><br><span class="line"></span><br><span class="line">        visit(p-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果该结点没有右子结点,则不执行下面while语句里面的语句,即令下次循环遍历该结点的右子结点.</span></span><br><span class="line">        <span class="comment">//如果下一个节点就是头结点,则也不进入下面while语句的循环体中.</span></span><br><span class="line">        <span class="comment">//下面的语句就是利用Thread的作用直接去判断,从而调用下一个需要遍历的结点(线索化的优点就出来了).</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;rtag == Thread &amp;&amp; p-&gt;rchild != T) &#123;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">            visit(p-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//令p指向下一个结点,可以是右子结点,也可以是后继结点,取决于此时tag域的信息.</span></span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问该数据的函数,这里就简单的打印出来.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ElemType data)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="7-_main_28_29_u51FD_u6570"><a href="#7-_main_28_29_u51FD_u6570" class="headerlink" title="7.  main()函数"></a>7.  main()函数</h3><p>过程很简单,先创建二叉树,再进行线索化,最后进行迭代遍历:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BiThrTree tree = <span class="literal">NULL</span>, head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建二叉树</span></span><br><span class="line">    createBiThrTree(&amp;tree);</span><br><span class="line">    <span class="comment">//线索化二叉树的过程</span></span><br><span class="line">    inOrderThreading(&amp;head, tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"中序遍历的结点为:"</span>);</span><br><span class="line">    <span class="comment">//遍历整棵线索二叉树</span></span><br><span class="line">    inOrderTraverseThr(head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="8-__u6CE8_u610F_u7684_u90E8_u5206_3A"><a href="#8-__u6CE8_u610F_u7684_u90E8_u5206_3A" class="headerlink" title="8.  注意的部分:"></a>8.  注意的部分:</h3><ol>
<li>如上图所示的测试输入数据部分,我们需要输入(space代表着空格):<br>ABC(space)D(space)(space)(space)E(space)FG(space)(space)H(space)(space)<br>原因很简单,因为我们在创建二叉树的过程中判断空格是否为标准去结束这个递归过程.</li>
<li>时间复杂度:<br>  创建二叉树的过程:O(n)<br>  线索化的过程:O(n)<br>  中序遍历的过程:O(n)</li>
</ol>
<h3 id="9-__u5176_u4ED6_u90E8_u5206"><a href="#9-__u5176_u4ED6_u90E8_u5206" class="headerlink" title="9.  其他部分"></a>9.  其他部分</h3><p>这里安利两个flash动画去让大家更好的理解整个线索化的过程:</p>
<ol>
<li><a href="http://student.zjzk.cn/course_ware/data_structure/web/flashhtml/erchashuxiansuohua.htm" target="_blank" rel="external">动画:中序线索二叉树</a></li>
<li><a href="http://student.zjzk.cn/course_ware/data_structure/web/flashhtml/erchashuhouji.htm" target="_blank" rel="external">动画:寻找中序线索二叉树指定结点的后继</a></li>
</ol>
<p>本文的源代码下载:<br><a href="https://github.com/Crainax/DemoCode/blob/master/C/DataStructures/BinaryThreadTree.c" target="_blank" rel="external">https://github.com/Crainax/DemoCode/blob/master/C/DataStructures/BinaryThreadTree.c</a></p>
<h3 id="10-__u6587_u7AE0_u53C2_u8003"><a href="#10-__u6587_u7AE0_u53C2_u8003" class="headerlink" title="10. 文章参考"></a>10. 文章参考</h3><ul>
<li><a href="http://blog.csdn.net/u012771236/article/details/23467369" target="_blank" rel="external">【树】线索二叉树概念</a></li>
<li><a href="http://blog.163.com/zhoumhan_0351/blog/static/39954227200991293851204/" target="_blank" rel="external">17、线索二叉树的生成和遍历  </a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7EBF_u7D22_u4E8C_u53C9_u6811"><a href="#u7EBF_u7D22_u4E8C_u53C9_u6811" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><h3 id="1-__u]]>
    </summary>
    
      <category term="数据结构" scheme="http://crainax.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基本知识每日阅读笔记汇总]]></title>
    <link href="http://crainax.github.io/2016/02/08/daily/%E5%85%B6%E4%BB%96%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/"/>
    <id>http://crainax.github.io/2016/02/08/daily/其他基本知识每日阅读笔记汇总/</id>
    <published>2016-02-08T14:23:50.572Z</published>
    <updated>2016-03-05T17:29:58.263Z</updated>
    <content type="html"><![CDATA[<h1 id="u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u7ED3_u6784" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="C_u8BED_u8A00_u5185_u529F"><a href="#C_u8BED_u8A00_u5185_u529F" class="headerlink" title="C语言内功"></a>C语言内功</h2><blockquote>
<p>经过大一下的杨云涛神级讲解,使得现在C语言知识忘了好多,所以记录每日阅读过的笔记在这,以后再忘能回头再看~</p>
</blockquote>
<h3 id="u57FA_u672C_u8BED_u6CD5_u7684_u6DF1_u5165_u63A2_u8BA8"><a href="#u57FA_u672C_u8BED_u6CD5_u7684_u6DF1_u5165_u63A2_u8BA8" class="headerlink" title="基本语法的深入探讨"></a>基本语法的深入探讨</h3><ul>
<li><a href="http://blog.csdn.net/fengyunjh/article/details/6161343" target="_blank" rel="external">for循环语句头的执行顺序</a>(16/02/12)<br>(关键字:for循环,语句头,顺序)</li>
</ul>
<h3 id="u5173_u4E8Etypedef_struct_u7684_u7528_u6CD5"><a href="#u5173_u4E8Etypedef_struct_u7684_u7528_u6CD5" class="headerlink" title="关于typedef struct的用法"></a>关于typedef struct的用法</h3><ul>
<li><a href="http://blog.sina.com.cn/s/blog_4fdabc820100fsxu.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4fdabc820100fsxu.html</a>(16/02/08)<br>(关键字:关于typedef,struct的用法,C语言)</li>
</ul>
<h2 id="u7B97_u6CD5_u5206_u6790_u57FA_u7840"><a href="#u7B97_u6CD5_u5206_u6790_u57FA_u7840" class="headerlink" title="算法分析基础"></a>算法分析基础</h2><ul>
<li><a href="http://blog.csdn.net/RichardYSteven/article/details/5872672" target="_blank" rel="external">算法运行时间、logN、NlogN 之间的比较</a>(16/03/03)<br>(关键字:时间复杂度)</li>
</ul>
<h2 id="u7EBF_u6027_u8868"><a href="#u7EBF_u6027_u8868" class="headerlink" title="线性表"></a>线性表</h2><h3 id="u94FE_u8868"><a href="#u94FE_u8868" class="headerlink" title="链表"></a>链表</h3><h4 id="u94FE_u8868_u4E2D_u7684_u73AF"><a href="#u94FE_u8868_u4E2D_u7684_u73AF" class="headerlink" title="链表中的环"></a>链表中的环</h4><ul>
<li><a href="http://www.cnblogs.com/shuaiwhu/archive/2012/05/03/2480509.html" target="_blank" rel="external">判断单链表是否有环的两种方法</a>(16/02/13)<br>(关键字:单链表,环,判断)</li>
</ul>
<h4 id="u9759_u6001_u94FE_u8868_28Static_Linked_list_29"><a href="#u9759_u6001_u94FE_u8868_28Static_Linked_list_29" class="headerlink" title="静态链表(Static Linked list)"></a>静态链表(Static Linked list)</h4><ul>
<li><a href="http://blog.csdn.net/scu_daiwei/article/details/8511069" target="_blank" rel="external">静态链表</a>(16/02/11)<br>(关键字:静态链表)</li>
</ul>
<h2 id="u961F_u5217"><a href="#u961F_u5217" class="headerlink" title="队列"></a>队列</h2><h3 id="u5FAA_u73AF_u961F_u5217"><a href="#u5FAA_u73AF_u961F_u5217" class="headerlink" title="循环队列"></a>循环队列</h3><ul>
<li><a href="http://blog.csdn.net/huangkq1989/article/details/5719529" target="_blank" rel="external">循环队列的队空与队满的条件</a>(16/02/11)<br>(关键字:循环队列,队空,队满)</li>
</ul>
<h3 id="u6548_u7387_u95EE_u9898"><a href="#u6548_u7387_u95EE_u9898" class="headerlink" title="效率问题"></a>效率问题</h3><blockquote>
<p>对于单链表的插入原理是先查询后插入,时间复杂度是O(n),而顺序存储结构好像时间复杂度也是O(n),那为什么链表适用于插入而不适合查询呢?</p>
</blockquote>
<ul>
<li><a href="http://www.cnblogs.com/super-d2/archive/2012/08/10/2632064.html" target="_blank" rel="external">顺序存储结构与链式存储结构的比较（也可以说的顺序表与链表的比较）</a>(16/02/10)</li>
<li><a href="http://bbs.chinaunix.net/forum.php?mod=viewthread&amp;tid=1629550" target="_blank" rel="external">遍历链表与数组，哪个效率高</a>(16/02/10)<br>(关键字:链表,数组,效率)</li>
<li><a href="http://www.cskaoyan.com/redirect.php?fid=24&amp;tid=5539&amp;goto=nextoldset" target="_blank" rel="external">单链表删除和插入的时间复杂度是O（1）还是O（n）啊</a>(16/02/10)<br>(关键字:链表,数组,效率,时间复杂度)</li>
</ul>
<h2 id="u6811"><a href="#u6811" class="headerlink" title="树"></a>树</h2><h3 id="u4E8C_u53C9_u6811"><a href="#u4E8C_u53C9_u6811" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="u54C8_u592B_u66FC_u6811"><a href="#u54C8_u592B_u66FC_u6811" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><ul>
<li><a href="http://blog.csdn.net/arcsinsin/article/details/10153963" target="_blank" rel="external">哈夫曼树</a>(16/03/03)<br>(关键字:哈夫曼树,带权图,编码优化)</li>
<li><a href="http://blog.csdn.net/wuhao8989/article/details/10070851" target="_blank" rel="external">Huffman树</a>(16/03/03)<br>(关键字:哈夫曼树,带权图,编码优化)</li>
<li><a href="http://www.cnblogs.com/Braveliu/p/3453900.html" target="_blank" rel="external">赫夫曼树</a>(16/03/03)<br>(关键字:哈夫曼树,带权图,编码优化)</li>
<li><a href="http://www.roading.org/algorithm/introductiontoalgorithm/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.html" target="_blank" rel="external">赫夫曼编码</a>(16/03/03)<br>(关键字:哈夫曼树,带权图,编码优化)</li>
<li><a href="http://www.cnblogs.com/ghostll/p/3550802.html" target="_blank" rel="external">Huffman树&amp;&amp;Huffman编码</a>(16/03/03)<br>(关键字:哈夫曼树,带权图,编码优化)</li>
</ul>
<h1 id="u7B97_u6CD5"><a href="#u7B97_u6CD5" class="headerlink" title="算法"></a>算法</h1><h2 id="Chord_u7B97_u6CD5"><a href="#Chord_u7B97_u6CD5" class="headerlink" title="Chord算法"></a>Chord算法</h2><blockquote>
<p>在自顶向下中的P2P中的DHT的介绍中有关于Chord算法的使用,说得比较抽象,上网找了一下关于这种算法的资料.</p>
</blockquote>
<ul>
<li><a href="http://blog.csdn.net/wangxiaoqin00007/article/details/7374833" target="_blank" rel="external">Chord算法</a>(16/02/09)<br>(关键字:DHT,P2P,Chord,Stabilize,predecessor)</li>
</ul>
<h2 id="u5B57_u7B26_u4E32_u5339_u914D_u7B97_u6CD5"><a href="#u5B57_u7B26_u4E32_u5339_u914D_u7B97_u6CD5" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h2><h3 id="Brute_Force_u7B97_u6CD5"><a href="#Brute_Force_u7B97_u6CD5" class="headerlink" title="Brute Force算法"></a>Brute Force算法</h3><ul>
<li><a href="http://blog.csdn.net/timidsmile/article/details/8952113" target="_blank" rel="external">BF 算法</a>(16/02/27)<br>(关键字:BF算法,KMP算法优化前)</li>
</ul>
<h3 id="KMP_u7B97_u6CD5"><a href="#KMP_u7B97_u6CD5" class="headerlink" title="KMP算法"></a>KMP算法</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="external">字符串匹配的KMP算法</a>(16/02/27)<br>(关键字:KMP算法)</li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="external">从头到尾彻底理解KMP（2014年8月22日版）</a>(16/02/27)<br>(关键字:KMP算法)</li>
</ul>
<h1 id="u8BA1_u7B97_u673A_u7F51_u7EDC"><a href="#u8BA1_u7B97_u673A_u7F51_u7EDC" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="u5E94_u7528_u5C42_28Application_Layer_29"><a href="#u5E94_u7528_u5C42_28Application_Layer_29" class="headerlink" title="应用层(Application Layer)"></a>应用层(Application Layer)</h2><h3 id="u7535_u5B50_u90AE_u4EF6_28SMTP_29"><a href="#u7535_u5B50_u90AE_u4EF6_28SMTP_29" class="headerlink" title="电子邮件(SMTP)"></a>电子邮件(SMTP)</h3><h4 id="IMAP_u548CPOP3_u534F_u8BAE"><a href="#IMAP_u548CPOP3_u534F_u8BAE" class="headerlink" title="IMAP和POP3协议"></a>IMAP和POP3协议</h4><ul>
<li><a href="http://help.163.com/10/0203/13/5UJONJ4I00753VB8.html" target="_blank" rel="external">IMAP和POP3有什么区别?</a>(16/02/11)<br>(关键字:IMAP,POP3,SMTP)</li>
</ul>
<h3 id="u5BF9_u7B49_u6A21_u5F0F_28p2p_29"><a href="#u5BF9_u7B49_u6A21_u5F0F_28p2p_29" class="headerlink" title="对等模式(p2p)"></a>对等模式(p2p)</h3><h4 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h4><ul>
<li><a href="http://www.cnblogs.com/hnrainll/archive/2011/08/02/2125103.html" target="_blank" rel="external">BitTorrent详解</a>(16/02/10)<br>(关键字:BitTorrent,阻塞,optimistic unchoking,seed)</li>
</ul>
<h1 id="u5DE5_u5177_u5927_u6CD5_u597D"><a href="#u5DE5_u5177_u5927_u6CD5_u597D" class="headerlink" title="工具大法好"></a>工具大法好</h1><h2 id="Jerbrains"><a href="#Jerbrains" class="headerlink" title="Jerbrains"></a>Jerbrains</h2><ul>
<li><a href="http://blog.lanyus.com/archives/168.html" target="_blank" rel="external">Jerbrains系列15版激活码</a>(16/02/27)<br>(关键字:激活码)</li>
<li><a href="http://www.jikexueyuan.com/course/424_1.html?ss=2" target="_blank" rel="external">在 Windows 平台配置 GNU 环境</a>(16/02/27)<br>(关键字:Clion环境配置,MinGW)</li>
<li><a href="http://www.jikexueyuan.com/course/424_5.html?ss=2" target="_blank" rel="external">在 Windows 平台搭建 CLion 集成开发环境</a>(16/02/27)<br>(关键字:Clion环境配置,MinGW)</li>
</ul>
<h2 id="Chrome__u63D2_u4EF6"><a href="#Chrome__u63D2_u4EF6" class="headerlink" title="Chrome 插件"></a>Chrome 插件</h2><ul>
<li><a href="http://stormzhang.com/devtools/2016/01/15/google-chrome-extension/" target="_blank" rel="external"><br>私人珍藏的Chrome插件，吐血推荐</a>(16/03/06)<br>(关键字:Chrome插件)</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u7ED3_u6784" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="C_u8BED_u8A00_u5185]]>
    </summary>
    
      <category term="daily" scheme="http://crainax.github.io/categories/daily/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对于在Activity中的onCreate()方法中获取View的长宽为0的解决方法]]></title>
    <link href="http://crainax.github.io/2016/01/26/Android/%E5%AF%B9%E4%BA%8E%E5%9C%A8Activity%E4%B8%ADonCreate()%E6%96%B9%E6%B3%95%E4%B8%AD%E8%8E%B7%E5%8F%96View%E9%95%BF%E5%AE%BD%E4%B8%BA0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://crainax.github.io/2016/01/26/Android/对于在Activity中onCreate()方法中获取View长宽为0的解决方法/</id>
    <published>2016-01-26T10:19:21.087Z</published>
    <updated>2016-03-30T15:51:24.152Z</updated>
    <content type="html"><![CDATA[<h1 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h1><p>  相信不少朋友么总会遇到一个问题吧:想在Activity中的onCreate方法中想初始化一个控件,于是就在onCreate方法中这么写道:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//获取view的长宽并打印</span></span><br><span class="line">        System.out.println(<span class="string">"view.getWidth() = "</span> + view.getWidth());</span><br><span class="line">        System.out.println(<span class="string">"view.getHeight() = "</span> + view.getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  但是你会发现打印出来会出现这个结果:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span>-<span class="number">26</span> <span class="number">18</span>:<span class="number">33</span>:<span class="number">01.297</span> <span class="number">28386</span>-<span class="number">28386</span>/? I/System.out: view.getWidth() = <span class="number">0</span></span><br><span class="line"><span class="number">01</span>-<span class="number">26</span> <span class="number">18</span>:<span class="number">33</span>:<span class="number">01.297</span> <span class="number">28386</span>-<span class="number">28386</span>/? I/System.out: view.getHeight() = <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>  特别蛋疼,是不是?</p>
<h1 id="u95EE_u9898_u539F_u56E0"><a href="#u95EE_u9898_u539F_u56E0" class="headerlink" title="问题原因"></a>问题原因</h1><p>  这是因为在onCreate()方法中,activity设置了contentView后图像并不能第一时间就测量和绘制出来,此时用到这两个方法就会出现返回值为0的情况.</p>
<h1 id="u89E3_u51B3_u65B9_u6CD5"><a href="#u89E3_u51B3_u65B9_u6CD5" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="u5F02_u6B65_u5224_u65AD_u83B7_u53D6_u6CD5_28_u4E0D_u63A8_u8350_29"><a href="#u5F02_u6B65_u5224_u65AD_u83B7_u53D6_u6CD5_28_u4E0D_u63A8_u8350_29" class="headerlink" title="异步判断获取法(不推荐)"></a>异步判断获取法(不推荐)</h2><p>当时我的第一个想法就是新开一个线程,然后每隔一定的时间进行判断,判断获取长宽是否为0,直到不为0则跳出循环判断,类似代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (view.getWidth() != <span class="number">0</span> &amp;&amp; view.getHeight() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//Next step</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></p>
<p>  这样看似解决了问题,但是又出现了一个问题,就是这是个死循环,不加延时的话会特别占内存且特别卡,于是又想到了这样处理,在每次判断后延时100毫秒再进行下一次循环:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (view.getWidth() != <span class="number">0</span> &amp;&amp; view.getHeight() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//Next step</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></p>
<p>  这样就能很好的解决了长宽的问题了,但是有没有发现一个比较蛋疼的地方呢?就是每100毫秒进行一次判断.</p>
<p><strong>如果我101毫秒就读取完毕呢?那就浪费了99毫秒的时间,这个时间内用户可能会看到你没处理好的内容,体验就不会不太友好.</strong><br>而这时间也不是固定的,不能通过测试获取到这个时间,每台机器的性能也不同而异,时间长短肯定也不是一致的.<br><strong>所以这个方法是不推荐使用的</strong></p>
<h2 id="u4F7F_u7528ViewTreeObserver_u6765_u76D1_u542C_u83B7_u53D6"><a href="#u4F7F_u7528ViewTreeObserver_u6765_u76D1_u542C_u83B7_u53D6" class="headerlink" title="使用ViewTreeObserver来监听获取"></a>使用ViewTreeObserver来监听获取</h2><p>先贴代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">view.getViewTreeObserver().addOnPreDrawListener(<span class="keyword">new</span> ViewTreeObserver.OnPreDrawListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"view.getWidth() = "</span> + view.getWidth());</span><br><span class="line">        System.out.println(<span class="string">"view.getHeight() = "</span> + view.getHeight());</span><br><span class="line">        <span class="comment">//这里记得要改成true,不然onDraw方法就不会调用了.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这个方法类似于观察者模式,也比较好的能获取到长宽值,而且类如其名,onPreDraw,在绘制前调用.<br>但是经过调试,我们还会发现一个小问题:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span>-<span class="number">26</span> <span class="number">18</span>:<span class="number">55</span>:<span class="number">50.962</span> <span class="number">29438</span>-<span class="number">29438</span>/? I/System.out: view.getWidth() = <span class="number">1056</span></span><br><span class="line"><span class="number">01</span>-<span class="number">26</span> <span class="number">18</span>:<span class="number">55</span>:<span class="number">50.962</span> <span class="number">29438</span>-<span class="number">29438</span>/? I/System.out: view.getHeight() = <span class="number">1341</span></span><br><span class="line"><span class="number">01</span>-<span class="number">26</span> <span class="number">18</span>:<span class="number">55</span>:<span class="number">51.007</span> <span class="number">29438</span>-<span class="number">29438</span>/? I/System.out: view.getWidth() = <span class="number">1056</span></span><br><span class="line"><span class="number">01</span>-<span class="number">26</span> <span class="number">18</span>:<span class="number">55</span>:<span class="number">51.008</span> <span class="number">29438</span>-<span class="number">29438</span>/? I/System.out: view.getHeight() = <span class="number">1341</span></span><br><span class="line"><span class="number">01</span>-<span class="number">26</span> <span class="number">18</span>:<span class="number">55</span>:<span class="number">51.127</span> <span class="number">29438</span>-<span class="number">29438</span>/? I/System.out: view.getWidth() = <span class="number">1056</span></span><br><span class="line"><span class="number">01</span>-<span class="number">26</span> <span class="number">18</span>:<span class="number">55</span>:<span class="number">51.127</span> <span class="number">29438</span>-<span class="number">29438</span>/? I/System.out: view.getHeight() = <span class="number">1341</span></span><br></pre></td></tr></table></figure></p>
<p><strong>竟然会出现多次初始化!</strong><br>这就是在View中的onDraw方法频繁调用的原因了,所以这个方法也是不错的,但是需要一个Flag判断是不是第一次初始化,也比较麻烦.</p>
<h2 id="u81EA_u5B9A_u4E49View_u56DE_u8C03_u63A5_u53E3_u6CD5"><a href="#u81EA_u5B9A_u4E49View_u56DE_u8C03_u63A5_u53E3_u6CD5" class="headerlink" title="自定义View回调接口法"></a>自定义View回调接口法</h2><p>名副其实,如果这个View是自定义的View,我们完全可以自定义一个回调接口在View内部如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnSizeInitListener</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onsizeInit</span><span class="params">(<span class="keyword">int</span> width,<span class="keyword">int</span> height)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并定义好成员对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> OnSizeInitListener onSizeInitListener;</span><br></pre></td></tr></table></figure>
<p>暴露setter接口给外来对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnSizeInitListener</span><span class="params">(OnSizeInitListener onSizeInitListener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.onSizeInitListener = onSizeInitListener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与此同时,重写onSizeChanged方法,回调给监听对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(onSizeInitListener!= <span class="keyword">null</span>)</span><br><span class="line">        onSizeInitListener.onsizeInit(w,h);</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>别忘了在Activity中设置监听:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">view.setOnSizeInitListener(<span class="keyword">new</span> Clock.OnSizeInitListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeInit</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"width = "</span> + width);</span><br><span class="line">        System.out.println(<span class="string">"height = "</span> + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这样也就能获取到View的长和宽了.<br>但是可能你又会问到了:</p>
<ol>
<li>好像和第二种方法没什么区别呀,而且监听的方法比第二种方法还少?<br><strong>确实是这样,而且想额外监听其他方法的话还要重写其他接口,会更加麻烦,但是你能在内部定义第二种方法没有的Flag,实现初始化判断,毕竟onSizeChanged调用的次数有时也会很频繁!</strong></li>
<li>如果是原生的View,这个方法不就没有用了吗?<br><strong>此时我们可以换一种思路,新建一个MyView来进行包装原生的View(类似于装饰者模式),或者使用继承的方式去给这个View进行设置监听</strong></li>
</ol>
<h2 id="u7528View_u7684post_u65B9_u6CD5_u6765_u56DE_u8C03_u83B7_u53D6_28_u5F3A_u70C8_u63A8_u8350_29"><a href="#u7528View_u7684post_u65B9_u6CD5_u6765_u56DE_u8C03_u83B7_u53D6_28_u5F3A_u70C8_u63A8_u8350_29" class="headerlink" title="用View的post方法来回调获取(强烈推荐)"></a>用View的post方法来回调获取(强烈推荐)</h2><p>代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">view.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"view.getWidth() = "</span> + view.getWidth());</span><br><span class="line">        System.out.println(<span class="string">"view.getHeight() = "</span> + view.getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>看起来是不是比第一种方法简单粗暴许多?<br><strong>这样就能在Handler和Message的配合下,在视图创建完成后获取其长宽值了,而且不会多次进行初始化.</strong></p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>  上面的解决方案是我目前接触到的四种解决方案,其中第一种是我一开始不成熟的解决方法,大家可以忽略~~<br>  经过对比,大家也可以看出第四种比较方便,而且代码量也很少,极其适合用来做onCreate方法中第一次初始化时候的获取长宽,在长宽不会变化的View中适用.<br>  第三种自由度高,可以用来定制监听,比如说大小变化后也能快速的进行相应的操作,是不错的方法~<br>  至于第二种和第一种,大家见仁见智啦~</p>
<h2 id="u5982_u679C_u6709_u66F4_u597D_u7684_u83B7_u53D6_u957F_u5BBD_u65B9_u6CD5_2C_u6B22_u8FCE_u548C_u6211_u4EA4_u6D41_2C_u6216_u8005_u5728_u535A_u5BA2_u4E0B_u9762_u7559_u8A00_7E"><a href="#u5982_u679C_u6709_u66F4_u597D_u7684_u83B7_u53D6_u957F_u5BBD_u65B9_u6CD5_2C_u6B22_u8FCE_u548C_u6211_u4EA4_u6D41_2C_u6216_u8005_u5728_u535A_u5BA2_u4E0B_u9762_u7559_u8A00_7E" class="headerlink" title="如果有更好的获取长宽方法,欢迎和我交流,或者在博客下面留言~"></a>如果有更好的获取长宽方法,欢迎和我交流,或者在博客下面留言~</h2>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h1><p>  相信不少朋友么总会遇到一个问题吧:想在Activity中的onCreate方法中想初始化一个控件,于]]>
    </summary>
    
      <category term="android" scheme="http://crainax.github.io/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[android每日阅读笔记汇总]]></title>
    <link href="http://crainax.github.io/2016/01/01/daily/android%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/"/>
    <id>http://crainax.github.io/2016/01/01/daily/android每日阅读笔记汇总/</id>
    <published>2016-01-01T08:25:37.113Z</published>
    <updated>2016-04-19T05:01:36.761Z</updated>
    <content type="html"><![CDATA[<h1 id="android__u56DB_u5927_u7EC4_u4EF6_u4E4B_u4E00_Activity"><a href="#android__u56DB_u5927_u7EC4_u4EF6_u4E4B_u4E00_Activity" class="headerlink" title="android 四大组件之一 Activity"></a>android 四大组件之一 Activity</h1><h2 id="Activity_u7684_u4EFB_u52A1_u6808_u5206_u6790"><a href="#Activity_u7684_u4EFB_u52A1_u6808_u5206_u6790" class="headerlink" title="Activity的任务栈分析"></a>Activity的任务栈分析</h2><h3 id="resultCode_u4E3ARESULT_CANCEL_u7684_u539F_u56E0"><a href="#resultCode_u4E3ARESULT_CANCEL_u7684_u539F_u56E0" class="headerlink" title="resultCode为RESULT_CANCEL的原因"></a>resultCode为RESULT_CANCEL的原因</h3><blockquote>
<p>如果Activity的启动模式为SingleInstance或者singleTask的话.调用onActivityForResult会立即返回RESULT_CANCEL的请求码.</p>
</blockquote>
<ul>
<li><a href="http://blog.csdn.net/sodino/article/details/22101881" target="_blank" rel="external"> [Android]startActivityForResult启动singleTask的Activity，则onActivitResult()立即回调且resultCode为RESULT_CANCEL</a>(16/01/27)<br>(关键字:RESULT_CANCEL,Activity,resultCode,SingleTask,SingleInstance)</li>
</ul>
<h3 id="u542F_u7528_u4EFB_u52A1_u6808"><a href="#u542F_u7528_u4EFB_u52A1_u6808" class="headerlink" title="启用任务栈"></a>启用任务栈</h3><ul>
<li><a href="http://blog.csdn.net/vipzjyno1/article/details/25463457" target="_blank" rel="external">[置顶] Activity启动模式 及 Intent Flags 与 栈 的关联分析</a>(16/01/27)<br>(关键字:taskAffinity,FLAG_ACTIVITY_NEW_TASK ,FLAG_ACTIVITY_NO_HISTORY,任务栈)</li>
<li><blockquote>
<p>Android 群英传</p>
<ol>
<li>clearTaskOnLaunch 在Manifest中的属性:<br>每次在返回该Acvitity时,都将该Activity之上的所有Activity都清除.通过这个属性,可以让这个Task每次在初始化的时候,都只有这一个Activity.</li>
<li>finishOnTaskLaunch 与clearTaskOnLaunch类似,只不过clearTaskOnLaunch作用在别人身上,而finishOnTaskLaunch作用在自己身上.通过这个属性,当离开这个Activity所处的Task,那么用户再返回时,该Activity就会被finish掉.</li>
<li>alwaysRetainTaskState<br>这个属性给了Task一道”免死金牌”,如果将Activity这个属性设置为True,那么该Activity所在的Task将不接受任何清理命令</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Activity_u7684_u81EA_u52A8_u9500_u6BC1_u4FDD_u5B58_u6570_u636E_u673A_u5236_u2013onSaveInstanceState"><a href="#Activity_u7684_u81EA_u52A8_u9500_u6BC1_u4FDD_u5B58_u6570_u636E_u673A_u5236_u2013onSaveInstanceState" class="headerlink" title="Activity的自动销毁保存数据机制–onSaveInstanceState"></a>Activity的自动销毁保存数据机制–onSaveInstanceState</h2><h3 id="u5BF9_u4E8E_u8FD9_u4E24_u4E2A_u65B9_u6CD5_u7684_u89E6_u53D1_u65F6_u673A_3A"><a href="#u5BF9_u4E8E_u8FD9_u4E24_u4E2A_u65B9_u6CD5_u7684_u89E6_u53D1_u65F6_u673A_3A" class="headerlink" title="对于这两个方法的触发时机:"></a>对于这两个方法的触发时机:</h3><ul>
<li><a href="http://android.blog.51cto.com/268543/634646/" target="_blank" rel="external">onSaveInstanceState和onRestoreInstanceState触发的时机</a>(16/01/28)<br>(关键字:onSaveInstanceState、onRestoreInstanceState、触发时机)</li>
<li><a href="http://www.cnblogs.com/SharkBin/p/3539658.html" target="_blank" rel="external">onSaveInstanceState(Bundle outState)的调用时机</a>(16/01/28)<br>(关键字:onSaveInstanceState、没有PersistableBundle)<br><strong>注意:是没有PersistableBundle参数的onSaveInstanceState.</strong></li>
</ul>
<h3 id="u5BF9_u4E8E_Android_L_u4E2D_u65B0_u52A0_u5165_u7684_u5E26_u6709PersistableBundle_u53C2_u6570_u7684_u4E09_u4E2A_u65B9_u6CD5_u7684_u4ECB_u7ECD_3A"><a href="#u5BF9_u4E8E_Android_L_u4E2D_u65B0_u52A0_u5165_u7684_u5E26_u6709PersistableBundle_u53C2_u6570_u7684_u4E09_u4E2A_u65B9_u6CD5_u7684_u4ECB_u7ECD_3A" class="headerlink" title="对于 Android L中新加入的带有PersistableBundle参数的三个方法的介绍:"></a>对于 Android L中新加入的带有PersistableBundle参数的三个方法的介绍:</h3><ul>
<li><a href="http://blog.csdn.net/lincyang/article/details/45287599" target="_blank" rel="external">Android实战技巧之二十六：persistableMode与Activity的持久化
</a>(16/01/28)<br>(关键字:PersistableBundle,持久化,activity)</li>
</ul>
<hr>
<h1 id="android_Fragment"><a href="#android_Fragment" class="headerlink" title="android Fragment"></a>android Fragment</h1><h2 id="Fragment_u4E0EActivity_u7684_u4EA4_u4E92"><a href="#Fragment_u4E0EActivity_u7684_u4EA4_u4E92" class="headerlink" title="Fragment与Activity的交互"></a>Fragment与Activity的交互</h2><ul>
<li><a href="http://www.cnblogs.com/dyllove98/archive/2013/07/12/3186932.html" target="_blank" rel="external">API拾遗录之Fragment(其中有各种Menus的交互)</a>(16/01/25)<br>(关键字:OptionsMenu交互,setHasOptionsMenu,Fragment,回调)</li>
</ul>
<hr>
<h1 id="android_View"><a href="#android_View" class="headerlink" title="android View"></a>android View</h1><h2 id="onSizeChange"><a href="#onSizeChange" class="headerlink" title="onSizeChange"></a>onSizeChange</h2><ul>
<li><a href="http://www.tuicool.com/articles/Vfy2I3" target="_blank" rel="external">android 系统回调onSizeChange, onMeasure, onLayout调用时机</a>(16/01/22)</li>
<li><a href="http://blog.csdn.net/jason0539/article/details/9896743" target="_blank" rel="external">android之View的启动过程,有简单的onSizeChange调用时机分析</a>(16/01/22)</li>
</ul>
<h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h2><ul>
<li><a href="http://blog.sina.com.cn/s/blog_5da93c8f0101d4mx.html" target="_blank" rel="external">Android中Paint字体属性的设置</a>(16/01/22)<br>(关键字:Paint,Style,FIll,STROKE)</li>
<li><a href="http://kalogen.iteye.com/blog/1566111" target="_blank" rel="external">android中invalidate()的自动清屏含义以及屏幕刷新</a>(16/01/22)<br>(关键字:invalidate,onDraw)</li>
<li><a href="http://blog.sina.com.cn/s/blog_783ede0301012im3.html" target="_blank" rel="external">Android Canvas drawArc方法介绍</a>(16/01/22)<br>(关键字:弧形,drawArc,canvas)</li>
<li><a href="http://blog.csdn.net/qinjuning/article/details/7110211/" target="_blank" rel="external">Android中View绘制流程以及invalidate()等相关方法分析</a>(16/01/22)<br>(关键字:invalidate,绘制流程,onDraw)</li>
</ul>
<h2 id="u81EA_u5B9A_u4E49ViewGroup_u8FC7_u7A0B"><a href="#u81EA_u5B9A_u4E49ViewGroup_u8FC7_u7A0B" class="headerlink" title="自定义ViewGroup过程"></a>自定义ViewGroup过程</h2><h3 id="u4E0E_View__u5171_u6709_u4F46_u4E0D_u7C7B_u4F3C_u7684_u7ED8_u5236_u8FC7_u7A0B"><a href="#u4E0E_View__u5171_u6709_u4F46_u4E0D_u7C7B_u4F3C_u7684_u7ED8_u5236_u8FC7_u7A0B" class="headerlink" title="与 View 共有但不类似的绘制过程"></a>与 View 共有但不类似的绘制过程</h3><ul>
<li><a href="/Android onMeasure、Measure、measureChild、measureChildren 一些简要说明">Android onMeasure、Measure、measureChild、measureChildren 一些简要说明</a>(16/01/24)<br>(关键字:measureChild,ViewGroup)</li>
</ul>
<h3 id="u5173_u4E8EViewGroup_u4E2D_u7684Scroller_u7B80_u4ECB"><a href="#u5173_u4E8EViewGroup_u4E2D_u7684Scroller_u7B80_u4ECB" class="headerlink" title="关于ViewGroup中的Scroller简介"></a>关于ViewGroup中的Scroller简介</h3><ul>
<li><a href="http://ipjmc.iteye.com/blog/1615828" target="_blank" rel="external">Android Scroller简单用法</a>(16/01/24)<br>(关键字:Scroller,ViewGroup)</li>
<li><a href="http://www.cnblogs.com/supersugar/archive/2012/08/13/2636691.html" target="_blank" rel="external">Android中Scroller类的分析</a>(16/01/24)<br>(关键字:Scroller,invalidate,computeScroll)</li>
<li><a href="http://blog.csdn.net/c_weibin/article/details/7438323" target="_blank" rel="external">android 使用Scroller实现缓慢移动</a>(16/01/24)<br>(关键字:Scroller,computeScroll调用时机)</li>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/0413/1162.html" target="_blank" rel="external">对于getScrollX() 的理解</a>(16/01/24)<br>(关键字:SCroller,getScrollX)</li>
<li><strong><a href="http://www.cnblogs.com/wanqieddy/archive/2012/05/05/2484534.html" target="_blank" rel="external">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a></strong>(16/01/24)<br>(关键字:滑屏,Scroller)</li>
</ul>
<h3 id="u4F7F_u7528ViewDragHelper_u505A_u51FA_u66F4_u597D_u7684_u6ED1_u52A8_u5B9A_u5236_u6548_u679C"><a href="#u4F7F_u7528ViewDragHelper_u505A_u51FA_u66F4_u597D_u7684_u6ED1_u52A8_u5B9A_u5236_u6548_u679C" class="headerlink" title="使用ViewDragHelper做出更好的滑动定制效果"></a>使用ViewDragHelper做出更好的滑动定制效果</h3><ul>
<li><strong><a href="http://blog.csdn.net/lmj623565791/article/details/46858663" target="_blank" rel="external">Android ViewDragHelper完全解析 自定义ViewGroup神器</a></strong>(16/01/25)<br>(关键字:ViewDragHelper,侧滑,边界捕获,非正常捕获,事件消耗,滑动事件周期)</li>
</ul>
<h3 id="u4E00_u4E9B_u5B9E_u7528_u6280_u5DE7"><a href="#u4E00_u4E9B_u5B9E_u7528_u6280_u5DE7" class="headerlink" title="一些实用技巧"></a>一些实用技巧</h3><ul>
<li><a href="http://doc.okbase.net/zpj779878443/archive/121670.html" target="_blank" rel="external">New UI-妙用view的keepScreenOn属性保持屏幕常亮</a>(16/01/27)<br>(关键字:常亮)</li>
</ul>
<hr>
<h1 id="android__u5217_u8868"><a href="#android__u5217_u8868" class="headerlink" title="android 列表"></a>android 列表</h1><h2 id="u5BF9_u4E8E_u9B45_u65CF_u4E2D_u7684ListView_u4F1A_u51FA_u73B0_u4E0B_u62C9_u60AC_u505C_u7684_u89E3_u51B3_u65B9_u6CD5"><a href="#u5BF9_u4E8E_u9B45_u65CF_u4E2D_u7684ListView_u4F1A_u51FA_u73B0_u4E0B_u62C9_u60AC_u505C_u7684_u89E3_u51B3_u65B9_u6CD5" class="headerlink" title="对于魅族中的ListView会出现下拉悬停的解决方法"></a>对于魅族中的ListView会出现下拉悬停的解决方法</h2><ul>
<li><a href="http://blog.csdn.net/guijiaoba/article/details/41725795" target="_blank" rel="external">魅族手机中屏蔽ListView下拉悬停方法</a>(16/01/24)<br>(关键字:ListView,魅族适配,下拉悬停)</li>
</ul>
<h2 id="u5217_u8868_u4E2D_u7684_u5176_u4ED6_u6709_u7528_u90E8_u5206"><a href="#u5217_u8868_u4E2D_u7684_u5176_u4ED6_u6709_u7528_u90E8_u5206" class="headerlink" title="列表中的其他有用部分"></a>列表中的其他有用部分</h2><ul>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/0225/907.html" target="_blank" rel="external">ViewConfiguration.getScaledTouchSlop () 用法</a><br>(关键字:ViewConfiguration,ScaleTouchSlop,各种列表参数)</li>
</ul>
<hr>
<h1 id="android__u56FE_u50CF_u5904_u7406"><a href="#android__u56FE_u50CF_u5904_u7406" class="headerlink" title="android 图像处理"></a>android 图像处理</h1><h2 id="u4F7F_u7528bitmap_xml_u505A_u6210_u6709_u91CD_u590D_u6392_u7248_u6548_u679C_u7684drawable_u8D44_u6E90_u6548_u679C"><a href="#u4F7F_u7528bitmap_xml_u505A_u6210_u6709_u91CD_u590D_u6392_u7248_u6548_u679C_u7684drawable_u8D44_u6E90_u6548_u679C" class="headerlink" title="使用bitmap xml做成有重复排版效果的drawable资源效果"></a>使用bitmap xml做成有重复排版效果的drawable资源效果</h2><ul>
<li><a href="http://www.2cto.com/kf/201304/205818.html" target="_blank" rel="external">XML Bitmap</a>(16/01/26)<br>(关键字:Bitmap,xml,tileMode)</li>
</ul>
<h2 id="u4F7F_u7528Shape_u505A_u51FA_u5404_u79CD_u6709_u8DA3_u7684_u6548_u679C"><a href="#u4F7F_u7528Shape_u505A_u51FA_u5404_u79CD_u6709_u8DA3_u7684_u6548_u679C" class="headerlink" title="使用Shape做出各种有趣的效果"></a>使用Shape做出各种有趣的效果</h2><h3 id="Shape_u4E2D_u7684Gradient_u4E0B_u7684Angle_u5C5E_u6027_u7684_u4F5C_u7528_u8BE6_u89E3"><a href="#Shape_u4E2D_u7684Gradient_u4E0B_u7684Angle_u5C5E_u6027_u7684_u4F5C_u7528_u8BE6_u89E3" class="headerlink" title="Shape中的Gradient下的Angle属性的作用详解"></a>Shape中的Gradient下的Angle属性的作用详解</h3><ul>
<li><a href="http://blog.csdn.net/loongggdroid/article/details/9464173" target="_blank" rel="external">Android (shape,gradient)使用总结</a>(16/01/26)<br>(关键字:Shape,Gradient,Angle)</li>
</ul>
<h2 id="u4F7F_u7528Shader_u5BF9_u753B_u7B14_u6216_u8005_u56FE_u50CF_u8FDB_u884C_u64CD_u4F5C_u5904_u7406"><a href="#u4F7F_u7528Shader_u5BF9_u753B_u7B14_u6216_u8005_u56FE_u50CF_u8FDB_u884C_u64CD_u4F5C_u5904_u7406" class="headerlink" title="使用Shader对画笔或者图像进行操作处理"></a>使用Shader对画笔或者图像进行操作处理</h2><ul>
<li><a href="http://www.php100.com/html/it/qianduan/2014/1226/8188.html" target="_blank" rel="external">Android BitmapShader实现圆形和圆角图片</a>(16/01/23)<br>(关键字:Shader,圆角)</li>
<li><a href="http://blog.csdn.net/sjf0115/article/details/7267220" target="_blank" rel="external">Android学习笔记进阶15之Shader渲染</a>(16/01/23)<br>(关键字:Shader,图片渲染)</li>
</ul>
<h2 id="u4F7F_u7528Xfermode_u5B9E_u73B0_u56FE_u7247_u6DF7_u5408_u6548_u679C"><a href="#u4F7F_u7528Xfermode_u5B9E_u73B0_u56FE_u7247_u6DF7_u5408_u6548_u679C" class="headerlink" title="使用Xfermode实现图片混合效果"></a>使用Xfermode实现图片混合效果</h2><p><a href="http://blog.csdn.net/lmj623565791/article/details/24555655" target="_blank" rel="external"></a>(16/01/27)<br>(关键字:Xfermode,圆角图片,混合图层,混合通道))</p>
<hr>
<h1 id="android_u7CFB_u7EDF"><a href="#android_u7CFB_u7EDF" class="headerlink" title="android系统"></a>android系统</h1><h2 id="u83B7_u53D6android_u8BBE_u5907_u4E2D_u7684_u53EF_u7528_u5185_u5B58"><a href="#u83B7_u53D6android_u8BBE_u5907_u4E2D_u7684_u53EF_u7528_u5185_u5B58" class="headerlink" title="获取android设备中的可用内存"></a>获取android设备中的可用内存</h2><blockquote>
<p>ActivityManager.MemoryInfo中有几个非常重要的字段,availMem–系统可能上,totalMem–总内存,threshold–低内存的阈值,即区分是否低内在的临界值,lowMemory–是否处于低 内存.</p>
</blockquote>
<ul>
<li><a href="http://blog.csdn.net/xujinsmile/article/details/8464327" target="_blank" rel="external">Android开发学习笔记（十二） 获取系统可用内存</a>(16/01/01)<br>(关键字:Formatter,内存,MemoryInfo)</li>
<li><blockquote>
<h4 id="anrdoid_u7FA4_u82F1_u4F20_2816/01/01_29"><a href="#anrdoid_u7FA4_u82F1_u4F20_2816/01/01_29" class="headerlink" title="anrdoid群英传(16/01/01)"></a>anrdoid群英传(16/01/01)</h4><p>使用 ActivityManager下的RunningAppProocessInfo可以获取到运行进程的信息,比如说以下信息:</p>
<ul>
<li>processName,进程名字</li>
<li>pid,进程pid</li>
<li>udi,进程uid<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用ActivityManager下的MemoryInfo去获取内存信息.</span></span><br><span class="line">ActivityManager.MemoryInfo memoryInfo = <span class="keyword">new</span> ActivityManager.MemoryInfo();</span><br><span class="line">am.getMemoryInfo(memoryInfo);</span><br><span class="line">tv.append(Formatter.formatFileSize(<span class="keyword">this</span>, memoryInfo.availMem) + <span class="string">","</span>);</span><br><span class="line">tv.append(memoryInfo.lowMemory + <span class="string">","</span>);</span><br><span class="line">tv.append(Formatter.formatFileSize(<span class="keyword">this</span>, memoryInfo.threshold) + <span class="string">","</span>);</span><br><span class="line">tv.append(Formatter.formatFileSize(<span class="keyword">this</span>, memoryInfo.totalMem) + <span class="string">","</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>这样就基本可以知道某些手机卫士的工作原理了.</p>
<blockquote>
<p>而RunningServiceInfo与上面类似可以获取所有当前运行的服务,这项功能可以用来判断服务是否存在以完成某些特定的功能,比如初始化UI,或者也类似于360的优化内存功能.<br>Debug.MemoryInfo 类中能通过pid去检索所占用的内存空间.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ActivityManager.RunningAppProcessInfo&gt; infos = am.getRunningAppProcesses();</span><br><span class="line"><span class="keyword">for</span> (ActivityManager.RunningAppProcessInfo info : infos) &#123;</span><br><span class="line">    <span class="keyword">int</span> pid = info.pid;</span><br><span class="line">    <span class="keyword">int</span> uid = info.uid;</span><br><span class="line">    String processName = info.processName;</span><br><span class="line">    Debug.MemoryInfo memoryInfo = am.getProcessMemoryInfo(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;pid&#125;)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> totalPss = memoryInfo.getTotalPss();</span><br><span class="line">    <span class="keyword">int</span> dalvikPss = memoryInfo.dalvikPss;</span><br><span class="line">    tv.append(pid + <span class="string">","</span>);</span><br><span class="line">    tv.append(uid + <span class="string">","</span>);</span><br><span class="line">    tv.append(processName + <span class="string">","</span>);</span><br><span class="line">    tv.append(totalPss + <span class="string">","</span>);</span><br><span class="line">    tv.append(dalvikPss + <span class="string">"."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>(关键字:ActivityManager,Info,应用信息,系统内存)</p>
<ul>
<li><a href="http://blog.csdn.net/hudashi/article/details/7050897" target="_blank" rel="external">Android中如何查看内存(上)</a>(16/01/01)<br>(关键字:底层,内存,pss,dalvik,ActivityManager,MemoryInfo,adb,shell)</li>
</ul>
<h2 id="u4F7F_u7528google_u63D0_u4F9B_u7684_u5DE5_u5177_u8FDB_u884C_u53CD_u7F16_u8BD1"><a href="#u4F7F_u7528google_u63D0_u4F9B_u7684_u5DE5_u5177_u8FDB_u884C_u53CD_u7F16_u8BD1" class="headerlink" title="使用google提供的工具进行反编译"></a>使用google提供的工具进行反编译</h2><blockquote>
<p>今天花了很多时间在尝试反编译,都出现很多问题的情况下,收集了很多相关的网站,以方便遇到同样问题的人能更好的解决而不必折腾.</p>
</blockquote>
<ul>
<li><a href="http://blog.csdn.net/vipzjyno1/article/details/21039349/" target="_blank" rel="external">Android APK反编译就这么简单 详解（附图）</a>(16/01/19)<br>(关键字:反编译,重打包,apktool,dex2jar,jd-gui)</li>
<li><a href="http://blog.csdn.net/aeolus1019/article/details/8119786" target="_blank" rel="external">brut.androlib.err.UndefinedResObject（完美解决）apktool反编译问题</a>(16/01/19)<br>(关键字:反编译,UndefinedResObject异常,apktool)</li>
<li><a href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="external">Apktool相关权威网站,有详细指导过程及常见问题</a>(16/01/19)<br>(关键字:apktool)</li>
<li><a href="http://blog.csdn.net/sam_zhang1984/article/details/8839175" target="_blank" rel="external">ApkTool反编译和重新打包</a>(16/01/21)<br>(关键字:apktool,重打包,签名,smali简单语法)</li>
</ul>
<h2 id="u4F7F_u7528Android_Studio_u8BBE_u7F6E_u7B7E_u540D_3B_u591A_u6E20_u9053_u6253_u5305"><a href="#u4F7F_u7528Android_Studio_u8BBE_u7F6E_u7B7E_u540D_3B_u591A_u6E20_u9053_u6253_u5305" class="headerlink" title="使用Android Studio设置签名;多渠道打包"></a>使用Android Studio设置签名;多渠道打包</h2><blockquote>
<p><em>引言</em><br>在使用apktool 进行反编译打包的,然后在手机进行安装会出现解析错误,不能安装的错误.上网看了一下,需要设置相应的签名才能安装<br><strong>(所以使用别人的资源重打包的时候如果 想覆盖别人的应用 ,就需要用到别人的签名,极大程度的保护了android的应用),但是如果仅仅用在汉化的用途,就可以用第二套应用.解决了这个疑问.</strong></p>
</blockquote>
<ul>
<li><a href="http://blog.csdn.net/yy1300326388/article/details/48344411" target="_blank" rel="external">［Android Studio 权威教程］打包、生成jks密钥、签名Apk、多渠道打包</a>(16/01/21)<br>(关键字:打包,sign,签名,密钥,多渠道)</li>
</ul>
<hr>
<h1 id="android__u8BBE_u8BA1"><a href="#android__u8BBE_u8BA1" class="headerlink" title="android 设计"></a>android 设计</h1><h2 id="Material_Design"><a href="#Material_Design" class="headerlink" title="Material Design"></a>Material Design</h2><h3 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h3><ul>
<li><a href="http://www.jianshu.com/p/79604c3ddcae" target="_blank" rel="external">Android开发：最详细的 Toolbar 开发实践总结</a>(16/02/23)<br>(关键字:Toolbar,细节)</li>
</ul>
<h3 id="u900F_u660E_u72B6_u6001_u680F_u5B9E_u6218"><a href="#u900F_u660E_u72B6_u6001_u680F_u5B9E_u6218" class="headerlink" title="透明状态栏实战"></a>透明状态栏实战</h3><ul>
<li><a href="http://www.jianshu.com/p/0acc12c29c1b" target="_blank" rel="external">Android开发：Translucent System Bar 的最佳实践</a>(16/02/23)<br>(关键字:StatusBar,状态栏,沉浸式状态栏)</li>
</ul>
<hr>
<h1 id="android__u4F18_u5316"><a href="#android__u4F18_u5316" class="headerlink" title="android 优化"></a>android 优化</h1><h2 id="android__u81EA_u5B9A_u4E49View__u4F18_u5316"><a href="#android__u81EA_u5B9A_u4E49View__u4F18_u5316" class="headerlink" title="android 自定义View 优化"></a>android 自定义View 优化</h2><ul>
<li><a href="http://www.bubuko.com/infodetail-185926.html" target="_blank" rel="external">Android中关于在onDraw或者onMeasure中创建对象提示Avoid object allocations during draw/layout operations (preallocate and reuse instead) 问题</a>(16/01/22)<br>(关键字:onDraw,优化,对象创建)</li>
<li><strong><a href="http://www.2cto.com/kf/201504/390390.html" target="_blank" rel="external">Android性能优化系列——Understanding Overdraw</a></strong>(16/01/28)<br>(关键字:OverDraw优化,开发者工具,GPU)</li>
<li><a href="http://blog.csdn.net/xu_fu/article/details/45008779" target="_blank" rel="external">Android性能优化系列——Profile GPU Rendering</a>(16/01/28)<br>(关键字:GPU渲染,开发者工具,OpenGL,关键帧)</li>
</ul>
<h2 id="u5206_u6790_u65B9_u6CD5_u5361_u987F_u7684_u795E_u5668TraceView"><a href="#u5206_u6790_u65B9_u6CD5_u5361_u987F_u7684_u795E_u5668TraceView" class="headerlink" title="分析方法卡顿的神器TraceView"></a>分析方法卡顿的神器TraceView</h2><ul>
<li><a href="http://blog.jobbole.com/78995/" target="_blank" rel="external">正确使用Android性能分析工具——TraceView</a>(16/01/28)<br>(关键字:TraceView,卡顿分析,内存优化,方法分析)</li>
</ul>
<h2 id="u8FFD_u8E2A_u5185_u5B58_u6CC4_u9732_u7684_u5723_u5668_MAT_u2013_28MemoryAnalyzerTool_29"><a href="#u8FFD_u8E2A_u5185_u5B58_u6CC4_u9732_u7684_u5723_u5668_MAT_u2013_28MemoryAnalyzerTool_29" class="headerlink" title="追踪内存泄露的圣器 MAT–(MemoryAnalyzerTool)"></a>追踪内存泄露的圣器 MAT–(MemoryAnalyzerTool)</h2><ul>
<li><a href="http://bjyzxxds.iteye.com/blog/1532937" target="_blank" rel="external">Shallow heap &amp; Retained heap的介绍</a>(16/01/28)<br>(关键字:MAT,内存泄露)</li>
<li><strong><a href="http://www.jianshu.com/p/c49f778e7acf" target="_blank" rel="external">使用Android studio分析内存泄露</a></strong>(16/01/28)<br>(关键字:MAT,内存泄露,内存优化,Handler)</li>
</ul>
<h2 id="android__u5185_u5B58_u6CC4_u9732"><a href="#android__u5185_u5B58_u6CC4_u9732" class="headerlink" title="android 内存泄露"></a>android 内存泄露</h2><h3 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>在MVP模式中,可以将Presenter中的mActivity设置成弱引用,这样如果在Presenter中要执行一些耗时操作而持有activity不能被回收导致内存泄露的情况发生.<br>那么,如果设置成弱引用不会出现随意被垃圾收集器处理的情况,而出现Presenter引用到activity对象的null情况吗?<br><strong> 答案: 在android 原生的某个地方已经将activity设置为强引用了,这也是activity的生命周期的实现原理,所以此时不需要担心这个问题,而需要注意当系统本应该清除activity时候能保证也能正常处理就行了. </strong></p>
</blockquote>
<ul>
<li><a href="http://blog.csdn.net/cyq1028/article/details/19980369" target="_blank" rel="external">Android内存泄漏分析及调试</a>(16/01/03)<br>(关键字:内存泄露,GC,Handler,MAT,引用类型)</li>
<li><a href="http://blog.csdn.net/stevenhu_223/article/details/18360397" target="_blank" rel="external">Android中的软引用(SoftRefrerence)和弱引用(WeakReference)</a>(16/01/03)<br>(关键字:引用类型,内存泄露,缓存机制)</li>
<li><a href="http://my.oschina.net/ydsakyclguozi/blog/404389?fromerr=n0OZIKDE" target="_blank" rel="external">Java 7之基础 - 强引用、弱引用、软引用、虚引用</a>(16/01/03)<br>(关键字:引用类型,生命周期)</li>
<li><a href="http://blog.sina.cn/dpool/blog/s/blog_4e1e357d0101kig2.html" target="_blank" rel="external">为什么在 activity中 使用handler为甚要声明为静态的</a>(16/01/03)<br>(关键字:Handler,内存泄露,静态类型)</li>
</ul>
<hr>
<h1 id="Android__u5DE5_u5177"><a href="#Android__u5DE5_u5177" class="headerlink" title="Android 工具"></a>Android 工具</h1><h2 id="Android__u5F00_u53D1_u5B98_u65B9IDE_3AAndroid_Studio"><a href="#Android__u5F00_u53D1_u5B98_u65B9IDE_3AAndroid_Studio" class="headerlink" title="Android 开发官方IDE:Android Studio"></a>Android 开发官方IDE:Android Studio</h2><h3 id="u5FEB_u6377_u952E_u53CA_u4F7F_u7528_u6280_u5DE7_u5927_u5168"><a href="#u5FEB_u6377_u952E_u53CA_u4F7F_u7528_u6280_u5DE7_u5927_u5168" class="headerlink" title="快捷键及使用技巧大全"></a>快捷键及使用技巧大全</h3><ul>
<li><a href="http://laobie.github.io/android/2016/02/14/android-studio-tips.html" target="_blank" rel="external">Android Studio 小技巧合集</a>(16/02/25)<br>(关键字:技巧,AS)</li>
</ul>
<h3 id="u5176_u4E0B_u7684Gradle"><a href="#u5176_u4E0B_u7684Gradle" class="headerlink" title="其下的Gradle"></a>其下的Gradle</h3><ul>
<li><a href="http://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="external">美团Android自动化之旅—生成渠道包</a>(16/04/10)<br>(关键字:自动化,渠道包,Maven,ApkTool)</li>
<li><a href="http://tech.meituan.com/mt-apk-adaptation.html" target="_blank" rel="external">美团Android自动化之旅—适配渠道包</a>(16/04/10)<br>(关键字:自动化,渠道包,Maven,各项渠道的不同)</li>
</ul>
<h3 id="u751F_u52A8_u751F_u6210_u5DE5_u5177"><a href="#u751F_u52A8_u751F_u6210_u5DE5_u5177" class="headerlink" title="生动生成工具"></a>生动生成工具</h3><ul>
<li><a href="http://blog.csdn.net/h70614959/article/details/22204347" target="_blank" rel="external"> Intellij IDEA 设置Java 文件File Header</a>(16/04/18)<br>(关键字:File Header,类头注释)</li>
</ul>
<h2 id="u4EE3_u7801_u89C4_u8303_u68C0_u6D4B_u5DE5_u5177Lint"><a href="#u4EE3_u7801_u89C4_u8303_u68C0_u6D4B_u5DE5_u5177Lint" class="headerlink" title="代码规范检测工具Lint"></a>代码规范检测工具Lint</h2><blockquote>
<p>内嵌在Android Studio 中的一个工具,可以自己定义出需要的代码约束及提示.</p>
</blockquote>
<ul>
<li><a href="http://www.bubuko.com/infodetail-1055648.html" target="_blank" rel="external">Android Studio使用Lint进行代码检查</a>(16/04/05)</li>
<li><a href="http://tech.meituan.com/android_custom_lint.html" target="_blank" rel="external">Android自定义Lint实践</a>(底部有官方教程)(16/04/05)</li>
</ul>
<h2 id="u9759_u6001_u4EE3_u7801_u68C0_u67E5_u5DE5_u5177Coverity"><a href="#u9759_u6001_u4EE3_u7801_u68C0_u67E5_u5DE5_u5177Coverity" class="headerlink" title="静态代码检查工具Coverity"></a>静态代码检查工具Coverity</h2><blockquote>
<p>这个库适用于Java,十分强大,能检测出类似单例模式中DCL写法不易发现的问题</p>
</blockquote>
<ul>
<li><a href="http://blog.csdn.net/yasi_xi/article/details/8349985" target="_blank" rel="external">Coverity 代码静态安全检测</a>(16/04/05)</li>
<li><a href="http://www.coverity.com/html_cn/" target="_blank" rel="external">点击进入官网</a>(16/04/05)</li>
</ul>
<h2 id="Android__u4EE3_u7801_u641C_u7D22_u795E_u5668__u2013_Codota"><a href="#Android__u4EE3_u7801_u641C_u7D22_u795E_u5668__u2013_Codota" class="headerlink" title="Android 代码搜索神器 – Codota"></a>Android 代码搜索神器 – Codota</h2><blockquote>
<p>正如codota 官方所说，的确是精品，他的搜索源，不仅只有Github，而且还有知名博客和开发者网站，让你搜索一个东西，不用在找上半天；</p>
</blockquote>
<ul>
<li><a href="http://www.jianshu.com/p/59b89c26f9e0" target="_blank" rel="external">Android 开发工具之Codota——搜索最好的Android 代码</a></li>
</ul>
<h2 id="u5DE5_u5177_u6536_u85CF_u5927_u5168"><a href="#u5DE5_u5177_u6536_u85CF_u5927_u5168" class="headerlink" title="工具收藏大全"></a><strong><a href="http://m.blog.csdn.net/article/details?id=51089422" target="_blank" rel="external">工具收藏大全</a></strong></h2><h2 id="IDEAVim"><a href="#IDEAVim" class="headerlink" title="IDEAVim"></a>IDEAVim</h2><ul>
<li><a href="http://www.cnblogs.com/nova-/p/3535636.html" target="_blank" rel="external">intellij idea 插件 ideaVim</a></li>
<li><a href="http://kidneyball.iteye.com/blog/1828427" target="_blank" rel="external">IdeaVim插件使用技巧</a></li>
<li><a href="http://kidneyball.iteye.com/blog/1814028" target="_blank" rel="external">IDEA Intellij小技巧和插件</a></li>
</ul>
<h2 id="Stetho_28FaceBook_u51FA_u54C1_29"><a href="#Stetho_28FaceBook_u51FA_u54C1_29" class="headerlink" title="Stetho(FaceBook出品)"></a>Stetho(FaceBook出品)</h2><ul>
<li><a href="http://blog.csdn.net/theone10211024/article/details/46531345" target="_blank" rel="external">安卓调试神器-Stetho(Facebook出品)的使用</a></li>
<li><a href="http://ju.outofmemory.cn/entry/119032" target="_blank" rel="external">使用Chrome来调试你的Android App</a></li>
</ul>
<hr>
<h1 id="Android__u65B0_u7279_u6027"><a href="#Android__u65B0_u7279_u6027" class="headerlink" title="Android 新特性"></a>Android 新特性</h1><h2 id="Android_6-0_MashMallow"><a href="#Android_6-0_MashMallow" class="headerlink" title="Android 6.0 MashMallow"></a>Android 6.0 MashMallow</h2><ul>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/50709663" target="_blank" rel="external">Android 6.0 运行时权限处理完全解析</a>(16/03/23)</li>
</ul>
<hr>
<h1 id="Android__u67B6_u6784"><a href="#Android__u67B6_u6784" class="headerlink" title="Android 架构"></a>Android 架构</h1><h2 id="MVP_u6A21_u5F0F"><a href="#MVP_u6A21_u5F0F" class="headerlink" title="MVP模式"></a>MVP模式</h2><ul>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/46596109" target="_blank" rel="external">浅谈 MVP in Android</a>(16/03/27)<br>(关键字:MVP)</li>
</ul>
<h2 id="u54CD_u5E94_u5F0F_u7F16_u7A0B_3A_RxJava"><a href="#u54CD_u5E94_u5F0F_u7F16_u7A0B_3A_RxJava" class="headerlink" title="响应式编程: RxJava"></a>响应式编程: RxJava</h2><ul>
<li><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">给 Android 开发者的 RxJava 详解</a>(16/04/17)<br>(关键字:RxJava,Retrofit,原理)</li>
</ul>
<h2 id="RESTful_u6A21_u5F0F__u4EE5_u53CA_Retrofit"><a href="#RESTful_u6A21_u5F0F__u4EE5_u53CA_Retrofit" class="headerlink" title="RESTful模式 以及 Retrofit"></a>RESTful模式 以及 Retrofit</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="external">理解RESTful架构</a>(16/04/17)<br>(关键字:RESTful)</li>
<li><a href="https://realm.io/cn/news/droidcon-jake-wharton-simple-http-retrofit-2/" target="_blank" rel="external">用 Retrofit 2 简化 HTTP 请求</a>(16/04/17)<br>(关键字:Retrofit2,HTTP)</li>
<li><a href="http://zhaoshanshan.me/2015/10/12/Retrofit2-%E6%9B%B4%E6%96%B0%E6%8C%87%E5%8D%97/" target="_blank" rel="external">Retrofit2 更新指南</a>(16/04/18)<br>(关键字:Retrofit2与Retrofit,不同之处,更新)</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="android__u56DB_u5927_u7EC4_u4EF6_u4E4B_u4E00_Activity"><a href="#android__u56DB_u5927_u7EC4_u4EF6_u4E4B_u4E00_Activity" class="heade]]>
    </summary>
    
      <category term="daily" scheme="http://crainax.github.io/categories/daily/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初次探索java注解(Annotation)]]></title>
    <link href="http://crainax.github.io/2015/12/31/Java/%E5%88%9D%E6%AC%A1%E6%8E%A2%E7%B4%A2java%20%E6%B3%A8%E8%A7%A3(Annotation)/"/>
    <id>http://crainax.github.io/2015/12/31/Java/初次探索java 注解(Annotation)/</id>
    <published>2015-12-31T03:05:55.784Z</published>
    <updated>2016-03-03T15:00:42.010Z</updated>
    <content type="html"><![CDATA[<h2 id="JavaSE__u81EA_u5E26_u7684_u6CE8_u89E3"><a href="#JavaSE__u81EA_u5E26_u7684_u6CE8_u89E3" class="headerlink" title="JavaSE 自带的注解"></a>JavaSE 自带的注解</h2><p>我们可以自定义一个类,其中定义了一个方法,并用Deprecated注解去标注该方法已经过时,可以看到在main方法中调用该方法会报出警告.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此时可以看出下面这句语句编译器是发出警告的</span></span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是用到java.lang包下的@SuppressWarnings注解就可以消除该警告:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此时警告消除</span></span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u81EA_u5B9A_u4E49_u6CE8_u89E3_u5B9E_u6218"><a href="#u81EA_u5B9A_u4E49_u6CE8_u89E3_u5B9E_u6218" class="headerlink" title="自定义注解实战"></a>自定义注解实战</h2><h3 id="1-_u83B7_u53D6_u6CE8_u89E3_u7684_u4FE1_u606F"><a href="#1-_u83B7_u53D6_u6CE8_u89E3_u7684_u4FE1_u606F" class="headerlink" title="1.获取注解的信息"></a>1.获取注解的信息</h3><p>我们可以使用Intellij  IDEA快速生成注解:<br><img src="http://7xpmqf.com1.z0.glb.clouddn.com/15-12-31/70085738.jpg" alt=""></p>
<p>自定义注解类代码如下:<br><strong>Description.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Description &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>引用注解类代码如下:<br><strong>MyAnn1.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Description</span>(<span class="string">"I am class annotation"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnn1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里会报错: @Description is nuo applicable to field,因为在定义注解时候我们没有在@Target中去定义field目标.所以我们</span></span><br><span class="line">    <span class="meta">@Description</span>(<span class="string">"I am field annotation"</span>)</span><br><span class="line">    <span class="keyword">private</span> String testField;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Description</span>(<span class="string">"I am method annotation"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再写一个解析处理器去处理这些注解信息,其中main方法入口也在这里:</p>
<h4 id="u5904_u7406_u81EA_u5B9A_u4E49_u6CE8_u89E3_u7684_u6B65_u9AA4_3A"><a href="#u5904_u7406_u81EA_u5B9A_u4E49_u6CE8_u89E3_u7684_u6B65_u9AA4_3A" class="headerlink" title="处理自定义注解的步骤:"></a>处理自定义注解的步骤:</h4><ol>
<li>首先用java 提供的反射方法获取类加载器</li>
<li>使用getAnnotation找到类下的注解,并获取其中已经定义的值.</li>
<li>再用类加载器的方法获取所有method,遍历判断是否有注解并获取到注解,从而获取到值.<br><strong>ParseAnn.java</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseAnn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//首先用java 提供的反射方法获取类加载器</span></span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">"diy.MyAnn1"</span>);<span class="comment">//这里需要注意加上包名不然会抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(Description.class)) &#123;</span><br><span class="line">                <span class="comment">//获取到类注解</span></span><br><span class="line">                Description description = clazz.getAnnotation(Description.class);</span><br><span class="line">                System.out.println(description.value());<span class="comment">//value()方法就是定义在注解类中的一个方法.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取方法下的类注解</span></span><br><span class="line">            Method[] methods = clazz.getMethods();</span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.isAnnotationPresent(Description.class)) &#123;</span><br><span class="line">                    Description description = method.getAnnotation(Description.class);</span><br><span class="line">                    System.out.println(description.value());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后运行,可以看到程序运行结果和预想的一样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am class annotation</span><br><span class="line">I am method annotation</span><br></pre></td></tr></table></figure></p>
<h3 id="u540E_u7EED_u66F4_u65B0_u4E2D_u2026"><a href="#u540E_u7EED_u66F4_u65B0_u4E2D_u2026" class="headerlink" title="后续更新中…."></a>后续更新中….</h3>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="JavaSE__u81EA_u5E26_u7684_u6CE8_u89E3"><a href="#JavaSE__u81EA_u5E26_u7684_u6CE8_u89E3" class="headerlink" title="JavaSE 自带的注解"></a>]]>
    </summary>
    
      <category term="java" scheme="http://crainax.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java每日阅读笔记汇总]]></title>
    <link href="http://crainax.github.io/2015/12/30/daily/java%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/"/>
    <id>http://crainax.github.io/2015/12/30/daily/java每日阅读笔记汇总/</id>
    <published>2015-12-30T14:40:43.701Z</published>
    <updated>2016-04-15T12:34:10.948Z</updated>
    <content type="html"><![CDATA[<h1 id="java_u57FA_u672C_u7C7B_u578B"><a href="#java_u57FA_u672C_u7C7B_u578B" class="headerlink" title="java基本类型"></a>java基本类型</h1><h2 id="u56DB_u9053Java_u57FA_u7840_u9898__u4F60_u80FD_u5BF9_u51E0_u9053_uFF1F"><a href="#u56DB_u9053Java_u57FA_u7840_u9898__u4F60_u80FD_u5BF9_u51E0_u9053_uFF1F" class="headerlink" title="四道Java基础题 你能对几道？"></a>四道Java基础题 你能对几道？</h2><h3 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h3><blockquote>
<h3 id="u56DB_u9053Java_u57FA_u7840_u9898__u4F60_u80FD_u5BF9_u51E0_u9053_uFF1F_2815/12/30_29"><a href="#u56DB_u9053Java_u57FA_u7840_u9898__u4F60_u80FD_u5BF9_u51E0_u9053_uFF1F_2815/12/30_29" class="headerlink" title="四道Java基础题 你能对几道？(15/12/30)"></a><a href="http://blog.csdn.net/soul_code/article/details/50369947" target="_blank" rel="external">四道Java基础题 你能对几道？</a>(15/12/30)</h3><p>一、==符在Integer中的判断<br>二、==在String中的判断<br>三、final关键字在内部类中的作用<br>四、Integer与int的几个判断<br>(关键字: 装箱,拆箱,final,常量池)</p>
</blockquote>
<h3 id="u6269_u5C55_u9605_u8BFB"><a href="#u6269_u5C55_u9605_u8BFB" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><ul>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="external">深入剖析Java中的装箱和拆箱</a>(15/12/30)<br>(关键字:javap 反编译,装箱,拆箱, valueOf)</li>
<li><a href="http://www.jb51.net/article/31934.htm" target="_blank" rel="external">java自动装箱拆箱深入剖析</a>(15/12/30)<br>(关键字:装箱,拆箱,javaSE5.0,享元模式,flyWeight)</li>
<li><a href="http://www.cnblogs.com/iyangyuan/p/4631696.html" target="_blank" rel="external">触摸java常量池</a>(15/12/30)<br>(关键字:常量池,jvm虚拟机,编译时期,class文件构造,jvm参数,)</li>
<li><a href="http://blog.csdn.net/olanlanxiari/article/details/8104505" target="_blank" rel="external">java常量池概念</a>(15/12/30)<br>(关键字:Integer源码,常量池)</li>
</ul>
<h2 id="u5BF9_u4E8Efor_u5FAA_u73AF_u4E2D_u7684i++__u548C_++i__u7684_u63A2_u8BA8"><a href="#u5BF9_u4E8Efor_u5FAA_u73AF_u4E2D_u7684i++__u548C_++i__u7684_u63A2_u8BA8" class="headerlink" title="对于for循环中的i++ 和 ++i 的探讨"></a>对于for循环中的i++ 和 ++i 的探讨</h2><h3 id="u6700_u7B80_u5355_u7684_u9A8C_u8BC1_u65B9_u5F0F_u5C31_u662F_u5199_u4EE3_u7801_u9A8C_u8BC1_u4E00_u4E0B_3A"><a href="#u6700_u7B80_u5355_u7684_u9A8C_u8BC1_u65B9_u5F0F_u5C31_u662F_u5199_u4EE3_u7801_u9A8C_u8BC1_u4E00_u4E0B_3A" class="headerlink" title="最简单的验证方式就是写代码验证一下:"></a>最简单的验证方式就是写代码验证一下:</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong> 结果如下: </strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">i = <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>所以可以看出在结果上这两种循环并没有什么区别</p>
<ul>
<li><a href="http://www.cskaoyan.com/thread-40999-1-1.html" target="_blank" rel="external">for循环中i++是不是比++i多循环一次？</a>(16/01/24)<br>(关键字:for循环)</li>
<li><a href="http://bbs.csdn.net/topics/30253911" target="_blank" rel="external">i++和++i用在for循环语句中有什么区别？</a>(16/01/24)<br>(关键字:for循环)</li>
<li><a href="http://blog.csdn.net/zy1691/article/details/4849808" target="_blank" rel="external">for循环中i++与++i的效率探究</a>(16/01/24)<br>(关键字:for循环,效率探究)</li>
</ul>
<hr>
<h1 id="java__u6301_u6709_u5BF9_u8C61"><a href="#java__u6301_u6709_u5BF9_u8C61" class="headerlink" title="java 持有对象"></a>java 持有对象</h1><h2 id="Hash_u6563_u5217"><a href="#Hash_u6563_u5217" class="headerlink" title="Hash散列"></a>Hash散列</h2><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><ul>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3681042.html" target="_blank" rel="external">浅谈Java中的hashcode方法</a>(16/04/01)<br>(关键字:euqals,hashCode,散列表)</li>
</ul>
<hr>
<h1 id="java__u7F51_u7EDC"><a href="#java__u7F51_u7EDC" class="headerlink" title="java 网络"></a>java 网络</h1><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><h3 id="u5F00_u6E90_u5E93_Okhttp"><a href="#u5F00_u6E90_u5E93_Okhttp" class="headerlink" title="开源库 Okhttp"></a>开源库 Okhttp</h3><ul>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html" target="_blank" rel="external">OkHttp使用教程</a>(16/04/12)</li>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/47911083" target="_blank" rel="external">Android OkHttp完全解析 是时候来了解OkHttp了</a>(16/04/12)</li>
</ul>
<h3 id="POST_u89E3_u6790"><a href="#POST_u89E3_u6790" class="headerlink" title="POST解析"></a>POST解析</h3><ul>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/23781773" target="_blank" rel="external">从原理角度解析Android （Java） http 文件上传</a>(16/04/11)<br>(关键字:http,post,socket,httpURLConnection)</li>
<li><a href="http://yefeng.iteye.com/blog/315847" target="_blank" rel="external">multipart form-data boundary 说明</a>(16/04/11)<br>(关键字:POST,BOUNDARY)</li>
</ul>
<h3 id="Cookie_u4E0ESession"><a href="#Cookie_u4E0ESession" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h3><ul>
<li><a href="http://www.cnblogs.com/shiyangxt/articles/1305506.html" target="_blank" rel="external">cookie 和session 的区别详解</a>(16/04/11)<br>(关键字:Cookie,Session)</li>
<li><a href="http://blog.csdn.net/sbsujjbcy/article/details/46895039" target="_blank" rel="external">Android OkHttp的Cookie自动化管理</a>(16/04/15)<br>(关键字:Cookie)</li>
<li><a href="http://blog.csdn.net/sbsujjbcy/article/details/47396659" target="_blank" rel="external">Android（Java） 模拟登录知乎并抓取用户信息</a>(16/04/15)<br>(关键字:OKHttp,POST,登录,Cookie持久化)</li>
</ul>
<hr>
<h1 id="java__u6CE8_u89E3"><a href="#java__u6CE8_u89E3" class="headerlink" title="java 注解"></a>java 注解</h1><h2 id="u521D_u6B21_u63A5_u89E6java__u6CE8_u89E3_28Annotation_29"><a href="#u521D_u6B21_u63A5_u89E6java__u6CE8_u89E3_28Annotation_29" class="headerlink" title="初次接触java 注解(Annotation)"></a>初次接触java 注解(Annotation)</h2><h3 id="u6269_u5C55_u9605_u8BFB-1"><a href="#u6269_u5C55_u9605_u8BFB-1" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><ul>
<li><a href="http://blog.csdn.net/mddy2001/article/details/8291484" target="_blank" rel="external">@SuppressWarnings的使用、作用、用法</a>(15/12/31)<br>(关键字: 注解,SuppressWarnings,参数)</li>
<li><a href="http://blog.csdn.net/cighao/article/details/50295751" target="_blank" rel="external">全面解析 Java 注解</a>(15/12/31)<br>(关键字:注解, )</li>
</ul>
<hr>
<h1 id="java__u679A_u4E3E"><a href="#java__u679A_u4E3E" class="headerlink" title="java 枚举"></a>java 枚举</h1><h2 id="u521D_u6B21_u63A5_u89E6java__u679A_u4E3E_28Enum_29"><a href="#u521D_u6B21_u63A5_u89E6java__u679A_u4E3E_28Enum_29" class="headerlink" title="初次接触java 枚举(Enum)"></a>初次接触java 枚举(Enum)</h2><h3 id="u6269_u5C55_u9605_u8BFB-2"><a href="#u6269_u5C55_u9605_u8BFB-2" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><ul>
<li><a href="http://blog.csdn.net/soul_code/article/details/50440183" target="_blank" rel="external">Java高级特性枚举</a>(16/01/02)<br><a href="https://github.com/Crainax/DemoCode/blob/master/Java/Demo/Demo_Enum/EnumTest.java" target="_blank" rel="external">点击查看demo代码</a><br>(关键字:枚举)</li>
</ul>
<h1 id="java__u8BBE_u8BA1_u6A21_u5F0F"><a href="#java__u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="java 设计模式"></a>java 设计模式</h1><h2 id="u5355_u4F8B_u6A21_u5F0F_28Singleton_29"><a href="#u5355_u4F8B_u6A21_u5F0F_28Singleton_29" class="headerlink" title="单例模式(Singleton)"></a>单例模式(Singleton)</h2><ul>
<li><a href="http://www.race604.com/java-double-checked-singleton/" target="_blank" rel="external">Java 单例真的写对了么?</a>(16/04/05)<br>(关键字:Coverity静态分析工具,volatile,java内存模型,DCL的不安全之处,单例方案)</li>
</ul>
<h2 id="u4EE3_u7406_u6A21_u5F0F_28Proxy_29"><a href="#u4EE3_u7406_u6A21_u5F0F_28Proxy_29" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h2><ul>
<li><a href="http://www.iteye.com/topic/683613/" target="_blank" rel="external">java 动态代理学习(Proxy,InvocationHandler)——自己的理解</a>(16/02/05)<br>(关键字:设计模式,Proxy,代理模式,InvocationHandler,反射,动态代理)</li>
</ul>
<h2 id="UML_u56FE_28_u7EDF_u4E00_u5EFA_u6A21_u8BED_u8A00_29"><a href="#UML_u56FE_28_u7EDF_u4E00_u5EFA_u6A21_u8BED_u8A00_29" class="headerlink" title="UML图(统一建模语言)"></a>UML图(统一建模语言)</h2><ul>
<li><a href="http://www.open-open.com/lib/view/open1328059700311.html" target="_blank" rel="external">UML类图几种关系的总结</a>(16/02/05)<br>(关键字:UML,泛化,实现,关联,聚合,组合,依赖)</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="java_u57FA_u672C_u7C7B_u578B"><a href="#java_u57FA_u672C_u7C7B_u578B" class="headerlink" title="java基本类型"></a>java基本类型</h1><h2 id="u]]>
    </summary>
    
      <category term="daily" scheme="http://crainax.github.io/categories/daily/"/>
    
  </entry>
  
</feed>
