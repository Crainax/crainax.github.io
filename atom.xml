<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[梦醒依旧流年.]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://crainax.github.io/"/>
  <updated>2016-03-28T14:35:34.576Z</updated>
  <id>http://crainax.github.io/</id>
  
  <author>
    <name><![CDATA[Crainax]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android收藏开源库汇总]]></title>
    <link href="http://crainax.github.io/2016/03/27/Android/Android%E6%94%B6%E8%97%8F%E5%BC%80%E6%BA%90%E5%BA%93%E6%B1%87%E6%80%BB/"/>
    <id>http://crainax.github.io/2016/03/27/Android/Android收藏开源库汇总/</id>
    <published>2016-03-27T15:47:50.368Z</published>
    <updated>2016-03-28T14:35:34.576Z</updated>
    <content type="html"><![CDATA[<h2 id="SlidingPaneLayout"><a href="#SlidingPaneLayout" class="headerlink" title="SlidingPaneLayout"></a>SlidingPaneLayout</h2><blockquote>
<p>这个库可以用做出像QQ一样的侧滑效果,也有点类似于DrawerLayout.</p>
</blockquote>
<ul>
<li><a href="http://my.oschina.net/summerpxy/blog/211835" target="_blank" rel="external">SlidingPaneLayout的基本使用</a></li>
<li><a href="http://blog.csdn.net/xyz_lmn/article/details/12618149" target="_blank" rel="external">Android UI开发第三十四篇——SlidingPaneLayout</a></li>
</ul>
<h2 id="u7B26_u5408MD_u8BBE_u8BA1_u7684_u5E95_u90E8BottomBar_u8BBE_u8BA1_u6807_u7B7E_u680F"><a href="#u7B26_u5408MD_u8BBE_u8BA1_u7684_u5E95_u90E8BottomBar_u8BBE_u8BA1_u6807_u7B7E_u680F" class="headerlink" title="符合MD设计的底部BottomBar设计标签栏"></a>符合MD设计的底部BottomBar设计标签栏</h2><ul>
<li><a href="https://github.com/roughike/BottomBar" target="_blank" rel="external">roughike/BottomBar</a><br><img src="https://raw.githubusercontent.com/aurelhubert/ahbottomnavigation/master/demo3.gif" alt=""></li>
<li><a href="/aurelhubert/ahbottomnavigation">aurelhubert/ahbottomnavigation</a><br><img src="https://raw.githubusercontent.com/roughike/BottomBar/master/demo2-badge.gif" alt=""></li>
</ul>
<h2 id="u5E26_u53EF_u9009_u9879_u7684_u5BC6_u7801_u8F93_u5165_u6846"><a href="#u5E26_u53EF_u9009_u9879_u7684_u5BC6_u7801_u8F93_u5165_u6846" class="headerlink" title="带可选项的密码输入框"></a>带可选项的密码输入框</h2><ul>
<li><a href="https://github.com/lisawray/passwordview" target="_blank" rel="external">lisawray/passwordview</a><br><img src="https://raw.githubusercontent.com/lisawray/passwordview/master/2016-3-15.png" alt=""></li>
</ul>
<h2 id="u96C6_u6210Emoji_u8868_u60C5_u7684_u5E93"><a href="#u96C6_u6210Emoji_u8868_u60C5_u7684_u5E93" class="headerlink" title="集成Emoji表情的库"></a>集成Emoji表情的库</h2><ul>
<li><a href="https://github.com/vanniktech/Emoji" target="_blank" rel="external">vanniktech/Emoji</a><br><img src="https://github.com/vanniktech/Emoji/raw/master/preview_2.png" alt=""></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="SlidingPaneLayout"><a href="#SlidingPaneLayout" class="headerlink" title="SlidingPaneLayout"></a>SlidingPaneLayout</h2><blockquote>
]]>
    </summary>
    
      <category term="android" scheme="http://crainax.github.io/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java小技巧汇总]]></title>
    <link href="http://crainax.github.io/2016/03/27/Java/Java%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/"/>
    <id>http://crainax.github.io/2016/03/27/Java/Java小技巧汇总/</id>
    <published>2016-03-27T08:24:24.441Z</published>
    <updated>2016-03-27T12:52:18.050Z</updated>
    <content type="html"><![CDATA[<p>这篇博文主要用于记录一些没见过的小tips~</p>
<ol>
<li>在Intellij IDEA中打开 assert关键字调试,应该在 Run-&gt;Run Configurations-&gt;VM Options中填写”-ea”,如下图<br><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-3-27/94499851.jpg" alt=""></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇博文主要用于记录一些没见过的小tips~</p>
<ol>
<li>在Intellij IDEA中打开 assert关键字调试,应该在 Run-&gt;Run Configurations-&gt;VM Options中填写”-ea”,如下图<br><img src="]]>
    </summary>
    
      <category term="Java" scheme="http://crainax.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线索二叉树的建立与遍历C语言实现过程详解]]></title>
    <link href="http://crainax.github.io/2016/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86/"/>
    <id>http://crainax.github.io/2016/03/02/数据结构/线索二叉树的建立与遍历/</id>
    <published>2016-03-02T10:39:23.820Z</published>
    <updated>2016-03-23T09:57:18.770Z</updated>
    <content type="html"><![CDATA[<h1 id="u7EBF_u7D22_u4E8C_u53C9_u6811"><a href="#u7EBF_u7D22_u4E8C_u53C9_u6811" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><h3 id="1-__u5B9A_u4E49"><a href="#1-__u5B9A_u4E49" class="headerlink" title="1.  定义"></a>1.  定义</h3><p>  n个结点有n-1个前驱和n-1个后继；一共有2n个链域，其中：n+1个空链域，n-1个指针域；因此, 可以用空链域来存放结点的前驱和后继。线索二叉树就是利用n+1个空链域来存放结点的前驱和后继结点的信息。<br><strong>用一张简单的图来了解一下线索二叉树与基本的二叉树的区别吧:</strong><br><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-3-23/49384488.jpg" alt=""></p>
<p>普通二叉树(图1)</p>
<p><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-3-2/69724597.jpg" alt=""></p>
<p>线索二叉树(图2)</p>
<p>  我们可以很清楚的看出,线索二叉树很好的利用了图1中的空指针的空间,使得这些指针能指向以中序遍历二叉树的方式的前驱与后继.不但解决二叉链表找左、右孩子困难的问题，也解决了无法在某个结点中直接找到该结点的前驱与后继的问题。</p>
<h3 id="2-__u7ED3_u70B9_u7ED3_u6784"><a href="#2-__u7ED3_u70B9_u7ED3_u6784" class="headerlink" title="2.  结点结构"></a>2.  结点结构</h3><p><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-3-2/5375677.jpg" alt=""><br>线索二叉树有5个域，比一般的二叉树要多出两个标志位的域：<br>Data域:存放数据的数据域<br>RChild域:指向右子结点(或后继结点)的指针<br>LChild域:指向左子结点(或前驱结点)的指针<br>RTag域:是一个标志域.当该域为0时,RChild是指向右子结点的指针.当该域为1时,则RChild是指向后继结点的指针.<br>LTag域:是一个标志域.当该域为0时,LChild是指向左子结点的指针.当该域为1时,则LChild是指向后继结点的指针.</p>
<p>头结点: 图中的Head结点.<br>根结点: 图中的A结点(二叉树的根结点).</p>
<h3 id="3-_u4E8C_u53C9_u6811_u7684_u7EBF_u7D22_u5316"><a href="#3-_u4E8C_u53C9_u6811_u7684_u7EBF_u7D22_u5316" class="headerlink" title="3.二叉树的线索化"></a>3.二叉树的线索化</h3><p>  有效利用二叉链表中空的存储空间,指定原有的孩子指针为空的域来存放指向前驱和后继的过程,称为线索化.</p>
<p>  简单点说:将二叉树变为线索二叉树的过程也就称为线索化.</p>
<h3 id="4-_u7EBF_u7D22_u4E8C_u53C9_u6811_u7684_u5B58_u50A8_u7ED3_u6784"><a href="#4-_u7EBF_u7D22_u4E8C_u53C9_u6811_u7684_u5B58_u50A8_u7ED3_u6784" class="headerlink" title="4.线索二叉树的存储结构"></a>4.线索二叉树的存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索二叉树中的数据域的存储类型,使用宏定义能实现一改全改的效果</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举类型,代表着标志域指示的指针域指向的是子结点还是前驱后继结点,能更加方便直观的看懂代码</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    Link, Thread</span><br><span class="line">&#125; PointerTag;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结点的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> BiThrNode &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> BiThrNode * lchild, * rchild;</span><br><span class="line">    PointerTag ltag, rtag;</span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure>
<h3 id="5-_u7EBF_u7D22_u4E8C_u53C9_u6811_u7684_u4E2D_u5E8F_u9012_u5F52_u7EBF_u7D22_u5316_u8FC7_u7A0B"><a href="#5-_u7EBF_u7D22_u4E8C_u53C9_u6811_u7684_u4E2D_u5E8F_u9012_u5F52_u7EBF_u7D22_u5316_u8FC7_u7A0B" class="headerlink" title="5.线索二叉树的中序递归线索化过程"></a>5.线索二叉树的中序递归线索化过程</h3><p>  线索化过程看起来挺复杂,但是经过下面几个步骤的分解也就看起来不是那么的难啦~</p>
<ol>
<li><p>以前序创建普通二叉树的方式创建一个未初始化的线索二叉树,以递归的形式去创建,其中当输入的字符为’ ‘时,代表该树没有孩子结点.代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序递归创建一个未线索化的二叉树</span></span><br><span class="line"><span class="comment">//参数: tree 线索二叉树的根结点指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBiThrTree</span><span class="params">(BiThrTree * tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">' '</span> == c) &#123; <span class="comment">//若输入的是空格,则不创建该结点,使得递归可以结束</span></span><br><span class="line">        * tree = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        * tree = ((BiThrTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode)));</span><br><span class="line">        <span class="comment">//设置其数据域</span></span><br><span class="line">        (* tree)-&gt;data = c;</span><br><span class="line">        <span class="comment">//未线索化的过程</span></span><br><span class="line">        (* tree)-&gt;ltag = Link;</span><br><span class="line">        (* tree)-&gt;rtag = Link;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归生成其左子结点</span></span><br><span class="line">        createBiThrTree(&amp;(* tree)-&gt;lchild);</span><br><span class="line">        <span class="comment">//递归生成其右子结点</span></span><br><span class="line">        createBiThrTree(&amp;(* tree)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个全局BiThrNode* 类型的指针变量pre(顾名思义就是上一个创建出来的结点),用于在递归生成结点的时候,记录上次的结点用于让生成的结点的前驱指针指向前驱的结点,然后再通过判断,若该pre结点rchild指针没有所指向,让其指向后继的结点(就是刚刚生成的结点).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BiThrNode *pre = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>增设一个头结点，令其lchild指向二叉树的根结点，ltag=0、rtag=1；并将该结点作为遍历访问的第一个结点的前驱和最后一个结点的后继；最后用头指针指示该头结点。其rchild域的指针指向中序遍历时访问的最后一个结点；反之，令二叉树中序序列中的第一个结点的lchild域指针和最后一个结点rchild域的指针均指向头结点，这好比为二叉树建立了一个双向线索链表，既可以从第一个结点起顺后继进行遍历，也可以从最后一个结点起顺前驱进行遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建头结点.</span></span><br><span class="line"><span class="comment">//参数: head 作为指向头结点的结点指针变量, tree 线索二叉树的根结点指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrderThreading</span><span class="params">(BiThrTree * head, BiThrTree tree)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建头结点</span></span><br><span class="line">    * head = (BiThrTree) malloc(sizeof(BiThrNode));</span><br><span class="line">    <span class="comment">//设置该头结点的左右标志位分别为非线索与线索</span></span><br><span class="line">    <span class="comment">//递归线索化的过程能使得第一个结点的前驱正确指向该头结点.</span></span><br><span class="line">    (* head)-&gt;ltag = Link;  </span><br><span class="line">    (* head)-&gt;rtag = Thread;</span><br><span class="line">    <span class="keyword">if</span> (!tree) &#123;</span><br><span class="line">        <span class="comment">//若根结点不存在,则该二叉树为空,让该头结点指向自身.</span></span><br><span class="line">        (* head)-&gt;lchild = * head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//令头结点的左指针指向根结点</span></span><br><span class="line">        (* head)-&gt;lchild = tree;</span><br><span class="line">        pre = * head;</span><br><span class="line">        <span class="comment">//开始递归输入线索化</span></span><br><span class="line">        inThreading(tree);</span><br><span class="line">        <span class="comment">//此时结束了最后一个结点的线索化了,下面的代码把头结点的后继指向了最后一个结点.</span></span><br><span class="line">        <span class="comment">//并把最后一个结点的后继也指向头结点,此时树成为了一个类似链表的循环.</span></span><br><span class="line">        pre-&gt;rchild = * head;</span><br><span class="line">        pre-&gt;rtag = Thread;</span><br><span class="line">        (* head)-&gt;rchild = pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上述代码即如下图所示的红线内的建立头结点的过程.<br><img src="http://7xpmqf.com1.z0.glb.clouddn.com/16-3-6/33263186.jpg" alt=""></p>
<ol>
<li>补全inThreading函数,使得其依次中序递归线索化子结点,此过程就是上图中红线之外的部分.<br>代码如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历线索化</span></span><br><span class="line"><span class="comment">//参数: tree 线索二叉树的根结点指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inThreading</span><span class="params">(BiThrTree tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree) &#123;</span><br><span class="line"></span><br><span class="line">        inThreading(tree-&gt;lchild); <span class="comment">//递归左孩子线索化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历处理内容</span></span><br><span class="line">        <span class="keyword">if</span> (!tree-&gt;lchild) &#123; <span class="comment">//如果该结点没有左孩子,设置ltag为Thread,并把lChild指向前驱结点</span></span><br><span class="line">            tree-&gt;ltag = Thread;</span><br><span class="line">            tree-&gt;lchild = pre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pre-&gt;rchild) &#123;<span class="comment">//处理pre结点(也就是上一个创建的结点),若其无右孩子,则令pre的rChild指向后继结点</span></span><br><span class="line">            pre-&gt;rtag = Thread;</span><br><span class="line">            pre-&gt;rchild = tree;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre = tree;<span class="comment">//令pre全局变量指向已经处理完毕的结点,令下个结点继续处理</span></span><br><span class="line">        <span class="comment">//中序遍历处理结束</span></span><br><span class="line"></span><br><span class="line">        inThreading(tree-&gt;rchild);<span class="comment">//递归右孩子线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p><strong>经过上面几个并不是很长的代码,我们就把新建的二叉树给线索化啦~<br>如果感觉并不能很好地了解上面的描述,可以在纸上去一步步地去演算整个递归过程~</strong></p>
<h3 id="6-_u8FED_u4EE3_u7684_u5F62_u5F0F_u53BB_u4E2D_u5E8F_u904D_u5386_u8BE5_u7EBF_u7D22_u4E8C_u53C9_u6811"><a href="#6-_u8FED_u4EE3_u7684_u5F62_u5F0F_u53BB_u4E2D_u5E8F_u904D_u5386_u8BE5_u7EBF_u7D22_u4E8C_u53C9_u6811" class="headerlink" title="6.迭代的形式去中序遍历该线索二叉树"></a>6.迭代的形式去中序遍历该线索二叉树</h3><p>  相信大家看到线索二叉树的存储结构也差不多知道怎么利用两个标签位去遍历整个线索二叉树了吧,下面就是代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以迭代的形式去中序遍历线索二叉树.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inOrderTraverseThr</span><span class="params">(BiThrTree T)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BiThrTree p = T-&gt;lchild;    <span class="comment">//令p先指向根节点.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出循环的条件是p重新指回了头结点.</span></span><br><span class="line">    <span class="keyword">while</span> (p != T) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;ltag == Link)</span><br><span class="line">            p = p-&gt;lchild;  <span class="comment">//迭代令p指向左子树为空的结点.</span></span><br><span class="line"></span><br><span class="line">        visit(p-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果该结点没有右子结点,则不执行下面while语句里面的语句,即令下次循环遍历该结点的右子结点.</span></span><br><span class="line">        <span class="comment">//如果下一个节点就是头结点,则也不进入下面while语句的循环体中.</span></span><br><span class="line">        <span class="comment">//下面的语句就是利用Thread的作用直接去判断,从而调用下一个需要遍历的结点(线索化的优点就出来了).</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;rtag == Thread &amp;&amp; p-&gt;rchild != T) &#123;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">            visit(p-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//令p指向下一个结点,可以是右子结点,也可以是后继结点,取决于此时tag域的信息.</span></span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问该数据的函数,这里就简单的打印出来.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ElemType data)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="7-_main_28_29_u51FD_u6570"><a href="#7-_main_28_29_u51FD_u6570" class="headerlink" title="7.  main()函数"></a>7.  main()函数</h3><p>过程很简单,先创建二叉树,再进行线索化,最后进行迭代遍历:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BiThrTree tree = <span class="literal">NULL</span>, head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建二叉树</span></span><br><span class="line">    createBiThrTree(&amp;tree);</span><br><span class="line">    <span class="comment">//线索化二叉树的过程</span></span><br><span class="line">    inOrderThreading(&amp;head, tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"中序遍历的结点为:"</span>);</span><br><span class="line">    <span class="comment">//遍历整棵线索二叉树</span></span><br><span class="line">    inOrderTraverseThr(head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="8-__u6CE8_u610F_u7684_u90E8_u5206_3A"><a href="#8-__u6CE8_u610F_u7684_u90E8_u5206_3A" class="headerlink" title="8.  注意的部分:"></a>8.  注意的部分:</h3><ol>
<li>如上图所示的测试输入数据部分,我们需要输入(space代表着空格):<br>ABC(space)D(space)(space)(space)E(space)FG(space)(space)H(space)(space)<br>原因很简单,因为我们在创建二叉树的过程中判断空格是否为标准去结束这个递归过程.</li>
<li>时间复杂度:<br>  创建二叉树的过程:O(n)<br>  线索化的过程:O(n)<br>  中序遍历的过程:O(n)</li>
</ol>
<h3 id="9-__u5176_u4ED6_u90E8_u5206"><a href="#9-__u5176_u4ED6_u90E8_u5206" class="headerlink" title="9.  其他部分"></a>9.  其他部分</h3><p>这里安利两个flash动画去让大家更好的理解整个线索化的过程:</p>
<ol>
<li><a href="http://student.zjzk.cn/course_ware/data_structure/web/flashhtml/erchashuxiansuohua.htm" target="_blank" rel="external">动画:中序线索二叉树</a></li>
<li><a href="http://student.zjzk.cn/course_ware/data_structure/web/flashhtml/erchashuhouji.htm" target="_blank" rel="external">动画:寻找中序线索二叉树指定结点的后继</a></li>
</ol>
<p>本文的源代码下载:<br><a href="https://github.com/Crainax/DemoCode/blob/master/C/DataStructures/BinaryThreadTree.c" target="_blank" rel="external">https://github.com/Crainax/DemoCode/blob/master/C/DataStructures/BinaryThreadTree.c</a></p>
<h3 id="10-__u6587_u7AE0_u53C2_u8003"><a href="#10-__u6587_u7AE0_u53C2_u8003" class="headerlink" title="10. 文章参考"></a>10. 文章参考</h3><ul>
<li><a href="http://blog.csdn.net/u012771236/article/details/23467369" target="_blank" rel="external">【树】线索二叉树概念</a></li>
<li><a href="http://blog.163.com/zhoumhan_0351/blog/static/39954227200991293851204/" target="_blank" rel="external">17、线索二叉树的生成和遍历  </a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7EBF_u7D22_u4E8C_u53C9_u6811"><a href="#u7EBF_u7D22_u4E8C_u53C9_u6811" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><h3 id="1-__u]]>
    </summary>
    
      <category term="数据结构" scheme="http://crainax.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基本知识每日阅读笔记汇总]]></title>
    <link href="http://crainax.github.io/2016/02/08/daily/%E5%85%B6%E4%BB%96%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/"/>
    <id>http://crainax.github.io/2016/02/08/daily/其他基本知识每日阅读笔记汇总/</id>
    <published>2016-02-08T14:23:50.572Z</published>
    <updated>2016-03-05T17:29:58.263Z</updated>
    <content type="html"><![CDATA[<h1 id="u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u7ED3_u6784" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="C_u8BED_u8A00_u5185_u529F"><a href="#C_u8BED_u8A00_u5185_u529F" class="headerlink" title="C语言内功"></a>C语言内功</h2><blockquote>
<p>经过大一下的杨云涛神级讲解,使得现在C语言知识忘了好多,所以记录每日阅读过的笔记在这,以后再忘能回头再看~</p>
</blockquote>
<h3 id="u57FA_u672C_u8BED_u6CD5_u7684_u6DF1_u5165_u63A2_u8BA8"><a href="#u57FA_u672C_u8BED_u6CD5_u7684_u6DF1_u5165_u63A2_u8BA8" class="headerlink" title="基本语法的深入探讨"></a>基本语法的深入探讨</h3><ul>
<li><a href="http://blog.csdn.net/fengyunjh/article/details/6161343" target="_blank" rel="external">for循环语句头的执行顺序</a>(16/02/12)<br>(关键字:for循环,语句头,顺序)</li>
</ul>
<h3 id="u5173_u4E8Etypedef_struct_u7684_u7528_u6CD5"><a href="#u5173_u4E8Etypedef_struct_u7684_u7528_u6CD5" class="headerlink" title="关于typedef struct的用法"></a>关于typedef struct的用法</h3><ul>
<li><a href="http://blog.sina.com.cn/s/blog_4fdabc820100fsxu.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4fdabc820100fsxu.html</a>(16/02/08)<br>(关键字:关于typedef,struct的用法,C语言)</li>
</ul>
<h2 id="u7B97_u6CD5_u5206_u6790_u57FA_u7840"><a href="#u7B97_u6CD5_u5206_u6790_u57FA_u7840" class="headerlink" title="算法分析基础"></a>算法分析基础</h2><ul>
<li><a href="http://blog.csdn.net/RichardYSteven/article/details/5872672" target="_blank" rel="external">算法运行时间、logN、NlogN 之间的比较</a>(16/03/03)<br>(关键字:时间复杂度)</li>
</ul>
<h2 id="u7EBF_u6027_u8868"><a href="#u7EBF_u6027_u8868" class="headerlink" title="线性表"></a>线性表</h2><h3 id="u94FE_u8868"><a href="#u94FE_u8868" class="headerlink" title="链表"></a>链表</h3><h4 id="u94FE_u8868_u4E2D_u7684_u73AF"><a href="#u94FE_u8868_u4E2D_u7684_u73AF" class="headerlink" title="链表中的环"></a>链表中的环</h4><ul>
<li><a href="http://www.cnblogs.com/shuaiwhu/archive/2012/05/03/2480509.html" target="_blank" rel="external">判断单链表是否有环的两种方法</a>(16/02/13)<br>(关键字:单链表,环,判断)</li>
</ul>
<h4 id="u9759_u6001_u94FE_u8868_28Static_Linked_list_29"><a href="#u9759_u6001_u94FE_u8868_28Static_Linked_list_29" class="headerlink" title="静态链表(Static Linked list)"></a>静态链表(Static Linked list)</h4><ul>
<li><a href="http://blog.csdn.net/scu_daiwei/article/details/8511069" target="_blank" rel="external">静态链表</a>(16/02/11)<br>(关键字:静态链表)</li>
</ul>
<h2 id="u961F_u5217"><a href="#u961F_u5217" class="headerlink" title="队列"></a>队列</h2><h3 id="u5FAA_u73AF_u961F_u5217"><a href="#u5FAA_u73AF_u961F_u5217" class="headerlink" title="循环队列"></a>循环队列</h3><ul>
<li><a href="http://blog.csdn.net/huangkq1989/article/details/5719529" target="_blank" rel="external">循环队列的队空与队满的条件</a>(16/02/11)<br>(关键字:循环队列,队空,队满)</li>
</ul>
<h3 id="u6548_u7387_u95EE_u9898"><a href="#u6548_u7387_u95EE_u9898" class="headerlink" title="效率问题"></a>效率问题</h3><blockquote>
<p>对于单链表的插入原理是先查询后插入,时间复杂度是O(n),而顺序存储结构好像时间复杂度也是O(n),那为什么链表适用于插入而不适合查询呢?</p>
</blockquote>
<ul>
<li><a href="http://www.cnblogs.com/super-d2/archive/2012/08/10/2632064.html" target="_blank" rel="external">顺序存储结构与链式存储结构的比较（也可以说的顺序表与链表的比较）</a>(16/02/10)</li>
<li><a href="http://bbs.chinaunix.net/forum.php?mod=viewthread&amp;tid=1629550" target="_blank" rel="external">遍历链表与数组，哪个效率高</a>(16/02/10)<br>(关键字:链表,数组,效率)</li>
<li><a href="http://www.cskaoyan.com/redirect.php?fid=24&amp;tid=5539&amp;goto=nextoldset" target="_blank" rel="external">单链表删除和插入的时间复杂度是O（1）还是O（n）啊</a>(16/02/10)<br>(关键字:链表,数组,效率,时间复杂度)</li>
</ul>
<h2 id="u6811"><a href="#u6811" class="headerlink" title="树"></a>树</h2><h3 id="u4E8C_u53C9_u6811"><a href="#u4E8C_u53C9_u6811" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="u54C8_u592B_u66FC_u6811"><a href="#u54C8_u592B_u66FC_u6811" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><ul>
<li><a href="http://blog.csdn.net/arcsinsin/article/details/10153963" target="_blank" rel="external">哈夫曼树</a>(16/03/03)<br>(关键字:哈夫曼树,带权图,编码优化)</li>
<li><a href="http://blog.csdn.net/wuhao8989/article/details/10070851" target="_blank" rel="external">Huffman树</a>(16/03/03)<br>(关键字:哈夫曼树,带权图,编码优化)</li>
<li><a href="http://www.cnblogs.com/Braveliu/p/3453900.html" target="_blank" rel="external">赫夫曼树</a>(16/03/03)<br>(关键字:哈夫曼树,带权图,编码优化)</li>
<li><a href="http://www.roading.org/algorithm/introductiontoalgorithm/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.html" target="_blank" rel="external">赫夫曼编码</a>(16/03/03)<br>(关键字:哈夫曼树,带权图,编码优化)</li>
<li><a href="http://www.cnblogs.com/ghostll/p/3550802.html" target="_blank" rel="external">Huffman树&amp;&amp;Huffman编码</a>(16/03/03)<br>(关键字:哈夫曼树,带权图,编码优化)</li>
</ul>
<h1 id="u7B97_u6CD5"><a href="#u7B97_u6CD5" class="headerlink" title="算法"></a>算法</h1><h2 id="Chord_u7B97_u6CD5"><a href="#Chord_u7B97_u6CD5" class="headerlink" title="Chord算法"></a>Chord算法</h2><blockquote>
<p>在自顶向下中的P2P中的DHT的介绍中有关于Chord算法的使用,说得比较抽象,上网找了一下关于这种算法的资料.</p>
</blockquote>
<ul>
<li><a href="http://blog.csdn.net/wangxiaoqin00007/article/details/7374833" target="_blank" rel="external">Chord算法</a>(16/02/09)<br>(关键字:DHT,P2P,Chord,Stabilize,predecessor)</li>
</ul>
<h2 id="u5B57_u7B26_u4E32_u5339_u914D_u7B97_u6CD5"><a href="#u5B57_u7B26_u4E32_u5339_u914D_u7B97_u6CD5" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h2><h3 id="Brute_Force_u7B97_u6CD5"><a href="#Brute_Force_u7B97_u6CD5" class="headerlink" title="Brute Force算法"></a>Brute Force算法</h3><ul>
<li><a href="http://blog.csdn.net/timidsmile/article/details/8952113" target="_blank" rel="external">BF 算法</a>(16/02/27)<br>(关键字:BF算法,KMP算法优化前)</li>
</ul>
<h3 id="KMP_u7B97_u6CD5"><a href="#KMP_u7B97_u6CD5" class="headerlink" title="KMP算法"></a>KMP算法</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="external">字符串匹配的KMP算法</a>(16/02/27)<br>(关键字:KMP算法)</li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="external">从头到尾彻底理解KMP（2014年8月22日版）</a>(16/02/27)<br>(关键字:KMP算法)</li>
</ul>
<h1 id="u8BA1_u7B97_u673A_u7F51_u7EDC"><a href="#u8BA1_u7B97_u673A_u7F51_u7EDC" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="u5E94_u7528_u5C42_28Application_Layer_29"><a href="#u5E94_u7528_u5C42_28Application_Layer_29" class="headerlink" title="应用层(Application Layer)"></a>应用层(Application Layer)</h2><h3 id="u7535_u5B50_u90AE_u4EF6_28SMTP_29"><a href="#u7535_u5B50_u90AE_u4EF6_28SMTP_29" class="headerlink" title="电子邮件(SMTP)"></a>电子邮件(SMTP)</h3><h4 id="IMAP_u548CPOP3_u534F_u8BAE"><a href="#IMAP_u548CPOP3_u534F_u8BAE" class="headerlink" title="IMAP和POP3协议"></a>IMAP和POP3协议</h4><ul>
<li><a href="http://help.163.com/10/0203/13/5UJONJ4I00753VB8.html" target="_blank" rel="external">IMAP和POP3有什么区别?</a>(16/02/11)<br>(关键字:IMAP,POP3,SMTP)</li>
</ul>
<h3 id="u5BF9_u7B49_u6A21_u5F0F_28p2p_29"><a href="#u5BF9_u7B49_u6A21_u5F0F_28p2p_29" class="headerlink" title="对等模式(p2p)"></a>对等模式(p2p)</h3><h4 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h4><ul>
<li><a href="http://www.cnblogs.com/hnrainll/archive/2011/08/02/2125103.html" target="_blank" rel="external">BitTorrent详解</a>(16/02/10)<br>(关键字:BitTorrent,阻塞,optimistic unchoking,seed)</li>
</ul>
<h1 id="u5DE5_u5177_u5927_u6CD5_u597D"><a href="#u5DE5_u5177_u5927_u6CD5_u597D" class="headerlink" title="工具大法好"></a>工具大法好</h1><h2 id="Jerbrains"><a href="#Jerbrains" class="headerlink" title="Jerbrains"></a>Jerbrains</h2><ul>
<li><a href="http://blog.lanyus.com/archives/168.html" target="_blank" rel="external">Jerbrains系列15版激活码</a>(16/02/27)<br>(关键字:激活码)</li>
<li><a href="http://www.jikexueyuan.com/course/424_1.html?ss=2" target="_blank" rel="external">在 Windows 平台配置 GNU 环境</a>(16/02/27)<br>(关键字:Clion环境配置,MinGW)</li>
<li><a href="http://www.jikexueyuan.com/course/424_5.html?ss=2" target="_blank" rel="external">在 Windows 平台搭建 CLion 集成开发环境</a>(16/02/27)<br>(关键字:Clion环境配置,MinGW)</li>
</ul>
<h2 id="Chrome__u63D2_u4EF6"><a href="#Chrome__u63D2_u4EF6" class="headerlink" title="Chrome 插件"></a>Chrome 插件</h2><ul>
<li><a href="http://stormzhang.com/devtools/2016/01/15/google-chrome-extension/" target="_blank" rel="external"><br>私人珍藏的Chrome插件，吐血推荐</a>(16/03/06)<br>(关键字:Chrome插件)</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u7ED3_u6784" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="C_u8BED_u8A00_u5185]]>
    </summary>
    
      <category term="daily" scheme="http://crainax.github.io/categories/daily/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对于在Activity中的onCreate()方法中获取View的长宽为0的解决方法]]></title>
    <link href="http://crainax.github.io/2016/01/26/Android/%E5%AF%B9%E4%BA%8E%E5%9C%A8Activity%E4%B8%ADonCreate()%E6%96%B9%E6%B3%95%E4%B8%AD%E8%8E%B7%E5%8F%96View%E9%95%BF%E5%AE%BD%E4%B8%BA0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://crainax.github.io/2016/01/26/Android/对于在Activity中onCreate()方法中获取View长宽为0的解决方法/</id>
    <published>2016-01-26T10:19:21.087Z</published>
    <updated>2016-01-26T11:22:57.165Z</updated>
    <content type="html"><![CDATA[<h1 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h1><p>  相信不少朋友么总会遇到一个问题吧:想在Activity中的onCreate方法中想初始化一个控件,于是就在onCreate方法中这么写道:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//获取view的长宽并打印</span></span><br><span class="line">        System.out.println(<span class="string">"view.getWidth() = "</span> + view.getWidth());</span><br><span class="line">        System.out.println(<span class="string">"view.getHeight() = "</span> + view.getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  但是你会发现打印出来会出现这个结果:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span>-<span class="number">26</span> <span class="number">18</span>:<span class="number">33</span>:<span class="number">01.297</span> <span class="number">28386</span>-<span class="number">28386</span>/? I/System.out: view.getWidth() = <span class="number">0</span></span><br><span class="line"><span class="number">01</span>-<span class="number">26</span> <span class="number">18</span>:<span class="number">33</span>:<span class="number">01.297</span> <span class="number">28386</span>-<span class="number">28386</span>/? I/System.out: view.getHeight() = <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>  特别蛋疼,是不是?</p>
<h1 id="u95EE_u9898_u539F_u56E0"><a href="#u95EE_u9898_u539F_u56E0" class="headerlink" title="问题原因"></a>问题原因</h1><p>  这是因为在onCreate()方法中,activity设置了contentView后图像并不能第一时间就测量和绘制出来,此时用到这两个方法就会出现返回值为0的情况.</p>
<h1 id="u89E3_u51B3_u65B9_u6CD5"><a href="#u89E3_u51B3_u65B9_u6CD5" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="u5F02_u6B65_u5224_u65AD_u83B7_u53D6_u6CD5_28_u4E0D_u63A8_u8350_29"><a href="#u5F02_u6B65_u5224_u65AD_u83B7_u53D6_u6CD5_28_u4E0D_u63A8_u8350_29" class="headerlink" title="异步判断获取法(不推荐)"></a>异步判断获取法(不推荐)</h2><p>当时我的第一个想法就是新开一个线程,然后每隔一定的时间进行判断,判断获取长宽是否为0,直到不为0则跳出循环判断,类似代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (view.getWidth() != <span class="number">0</span> &amp;&amp; view.getHeight() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//Next step</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></p>
<p>  这样看似解决了问题,但是又出现了一个问题,就是这是个死循环,不加延时的话会特别占内存且特别卡,于是又想到了这样处理,在每次判断后延时100毫秒再进行下一次循环:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (view.getWidth() != <span class="number">0</span> &amp;&amp; view.getHeight() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//Next step</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></p>
<p>  这样就能很好的解决了长宽的问题了,但是有没有发现一个比较蛋疼的地方呢?就是每100毫秒进行一次判断.</p>
<p><strong>如果我101毫秒就读取完毕呢?那就浪费了99毫秒的时间,这个时间内用户可能会看到你没处理好的内容,体验就不会不太友好.</strong><br>而这时间也不是固定的,不能通过测试获取到这个时间,每台机器的性能也不同而异,时间长短肯定也不是一致的.<br><strong>所以这个方法是不推荐使用的</strong></p>
<h2 id="u4F7F_u7528ViewTreeObserver_u6765_u76D1_u542C_u83B7_u53D6"><a href="#u4F7F_u7528ViewTreeObserver_u6765_u76D1_u542C_u83B7_u53D6" class="headerlink" title="使用ViewTreeObserver来监听获取"></a>使用ViewTreeObserver来监听获取</h2><p>先贴代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">view.getViewTreeObserver().addOnPreDrawListener(<span class="keyword">new</span> ViewTreeObserver.OnPreDrawListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"view.getWidth() = "</span> + view.getWidth());</span><br><span class="line">        System.out.println(<span class="string">"view.getHeight() = "</span> + view.getHeight());</span><br><span class="line">        <span class="comment">//这里记得要改成true,不然onDraw方法就不会调用了.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这个方法类似于观察者模式,也比较好的能获取到长宽值,而且类如其名,onPreDraw,在绘制前调用.<br>但是经过调试,我们还会发现一个小问题:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span>-<span class="number">26</span> <span class="number">18</span>:<span class="number">55</span>:<span class="number">50.962</span> <span class="number">29438</span>-<span class="number">29438</span>/? I/System.out: view.getWidth() = <span class="number">1056</span></span><br><span class="line"><span class="number">01</span>-<span class="number">26</span> <span class="number">18</span>:<span class="number">55</span>:<span class="number">50.962</span> <span class="number">29438</span>-<span class="number">29438</span>/? I/System.out: view.getHeight() = <span class="number">1341</span></span><br><span class="line"><span class="number">01</span>-<span class="number">26</span> <span class="number">18</span>:<span class="number">55</span>:<span class="number">51.007</span> <span class="number">29438</span>-<span class="number">29438</span>/? I/System.out: view.getWidth() = <span class="number">1056</span></span><br><span class="line"><span class="number">01</span>-<span class="number">26</span> <span class="number">18</span>:<span class="number">55</span>:<span class="number">51.008</span> <span class="number">29438</span>-<span class="number">29438</span>/? I/System.out: view.getHeight() = <span class="number">1341</span></span><br><span class="line"><span class="number">01</span>-<span class="number">26</span> <span class="number">18</span>:<span class="number">55</span>:<span class="number">51.127</span> <span class="number">29438</span>-<span class="number">29438</span>/? I/System.out: view.getWidth() = <span class="number">1056</span></span><br><span class="line"><span class="number">01</span>-<span class="number">26</span> <span class="number">18</span>:<span class="number">55</span>:<span class="number">51.127</span> <span class="number">29438</span>-<span class="number">29438</span>/? I/System.out: view.getHeight() = <span class="number">1341</span></span><br></pre></td></tr></table></figure></p>
<p><strong>竟然会出现多次初始化!</strong><br>这就是在View中的onDraw方法频繁调用的原因了,所以这个方法也是不错的,但是需要一个Flag判断是不是第一次初始化,也比较麻烦.</p>
<h2 id="u81EA_u5B9A_u4E49View_u56DE_u8C03_u63A5_u53E3_u6CD5"><a href="#u81EA_u5B9A_u4E49View_u56DE_u8C03_u63A5_u53E3_u6CD5" class="headerlink" title="自定义View回调接口法"></a>自定义View回调接口法</h2><p>名副其实,如果这个View是自定义的View,我们完全可以自定义一个回调接口在View内部如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnSizeInitListener</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onsizeInit</span><span class="params">(<span class="keyword">int</span> width,<span class="keyword">int</span> height)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并定义好成员对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> OnSizeInitListener onSizeInitListener;</span><br></pre></td></tr></table></figure>
<p>暴露setter接口给外来对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnSizeInitListener</span><span class="params">(OnSizeInitListener onSizeInitListener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.onSizeInitListener = onSizeInitListener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与此同时,重写onSizeChanged方法,回调给监听对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(onSizeInitListener!= <span class="keyword">null</span>)</span><br><span class="line">        onSizeInitListener.onsizeInit(w,h);</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>别忘了在Activity中设置监听:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">view.setOnSizeInitListener(<span class="keyword">new</span> Clock.OnSizeInitListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeInit</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"width = "</span> + width);</span><br><span class="line">        System.out.println(<span class="string">"height = "</span> + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这样也就能获取到View的长和宽了.<br>但是可能你又会问到了:</p>
<ol>
<li>好像和第二种方法没什么区别呀,而且监听的方法比第二种方法还少?<br><strong>确实是这样,而且想额外监听其他方法的话还要重写其他接口,会更加麻烦,但是你能在内部定义第二种方法没有的Flag,实现初始化判断,毕竟onSizeChanged调用的次数有时也会很频繁!</strong></li>
<li>如果是原生的View,这个方法不就没有用了吗?<br><strong>此时我们可以换一种思路,新建一个MyView来进行包装原生的View(类似于装饰者模式),或者使用继承的方式去给这个View进行设置监听</strong></li>
</ol>
<h2 id="u7528View_u7684post_u65B9_u6CD5_u6765_u56DE_u8C03_u83B7_u53D6_28_u5F3A_u70C8_u63A8_u8350_29"><a href="#u7528View_u7684post_u65B9_u6CD5_u6765_u56DE_u8C03_u83B7_u53D6_28_u5F3A_u70C8_u63A8_u8350_29" class="headerlink" title="用View的post方法来回调获取(强烈推荐)"></a>用View的post方法来回调获取(强烈推荐)</h2><p>代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">view.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"view.getWidth() = "</span> + view.getWidth());</span><br><span class="line">        System.out.println(<span class="string">"view.getHeight() = "</span> + view.getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>看起来是不是比第一种方法简单粗暴许多?<br><strong>这样就能在Handler和Message的配合下,在视图创建完成后获取其长宽值了,而且不会多次进行初始化.</strong></p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>  上面的解决方案是我目前接触到的四种解决方案,其中第一种是我一开始不成熟的解决方法,大家可以忽略~~<br>  经过对比,大家也可以看出第四种比较方便,而且代码量也很少,极其适合用来做onCreate方法中第一次初始化时候的获取长宽,在长宽不会变化的View中适用.<br>  第三种自由度高,可以用来定制监听,比如说大小变化后也能快速的进行相应的操作,是不错的方法~<br>  至于第二种和第一种,大家见仁见智啦~</p>
<h2 id="u5982_u679C_u6709_u66F4_u597D_u7684_u83B7_u53D6_u957F_u5BBD_u65B9_u6CD5_2C_u6B22_u8FCE_u548C_u6211_u4EA4_u6D41_2C_u6216_u8005_u5728_u535A_u5BA2_u4E0B_u9762_u7559_u8A00_7E"><a href="#u5982_u679C_u6709_u66F4_u597D_u7684_u83B7_u53D6_u957F_u5BBD_u65B9_u6CD5_2C_u6B22_u8FCE_u548C_u6211_u4EA4_u6D41_2C_u6216_u8005_u5728_u535A_u5BA2_u4E0B_u9762_u7559_u8A00_7E" class="headerlink" title="如果有更好的获取长宽方法,欢迎和我交流,或者在博客下面留言~"></a>如果有更好的获取长宽方法,欢迎和我交流,或者在博客下面留言~</h2>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h1><p>  相信不少朋友么总会遇到一个问题吧:想在Activity中的onCreate方法中想初始化一个控件,于]]>
    </summary>
    
      <category term="android" scheme="http://crainax.github.io/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[android每日阅读笔记汇总]]></title>
    <link href="http://crainax.github.io/2016/01/01/daily/android%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/"/>
    <id>http://crainax.github.io/2016/01/01/daily/android每日阅读笔记汇总/</id>
    <published>2016-01-01T08:25:37.113Z</published>
    <updated>2016-03-27T15:48:19.604Z</updated>
    <content type="html"><![CDATA[<h1 id="android__u56DB_u5927_u7EC4_u4EF6_u4E4B_u4E00_Activity"><a href="#android__u56DB_u5927_u7EC4_u4EF6_u4E4B_u4E00_Activity" class="headerlink" title="android 四大组件之一 Activity"></a>android 四大组件之一 Activity</h1><h2 id="Activity_u7684_u4EFB_u52A1_u6808_u5206_u6790"><a href="#Activity_u7684_u4EFB_u52A1_u6808_u5206_u6790" class="headerlink" title="Activity的任务栈分析"></a>Activity的任务栈分析</h2><h3 id="resultCode_u4E3ARESULT_CANCEL_u7684_u539F_u56E0"><a href="#resultCode_u4E3ARESULT_CANCEL_u7684_u539F_u56E0" class="headerlink" title="resultCode为RESULT_CANCEL的原因"></a>resultCode为RESULT_CANCEL的原因</h3><blockquote>
<p>如果Activity的启动模式为SingleInstance或者singleTask的话.调用onActivityForResult会立即返回RESULT_CANCEL的请求码.</p>
</blockquote>
<ul>
<li><a href="http://blog.csdn.net/sodino/article/details/22101881" target="_blank" rel="external"> [Android]startActivityForResult启动singleTask的Activity，则onActivitResult()立即回调且resultCode为RESULT_CANCEL</a>(16/01/27)<br>(关键字:RESULT_CANCEL,Activity,resultCode,SingleTask,SingleInstance)</li>
</ul>
<h3 id="u542F_u7528_u4EFB_u52A1_u6808"><a href="#u542F_u7528_u4EFB_u52A1_u6808" class="headerlink" title="启用任务栈"></a>启用任务栈</h3><ul>
<li><a href="http://blog.csdn.net/vipzjyno1/article/details/25463457" target="_blank" rel="external">[置顶] Activity启动模式 及 Intent Flags 与 栈 的关联分析</a>(16/01/27)<br>(关键字:taskAffinity,FLAG_ACTIVITY_NEW_TASK ,FLAG_ACTIVITY_NO_HISTORY,任务栈)</li>
<li><blockquote>
<p>Android 群英传</p>
<ol>
<li>clearTaskOnLaunch 在Manifest中的属性:<br>每次在返回该Acvitity时,都将该Activity之上的所有Activity都清除.通过这个属性,可以让这个Task每次在初始化的时候,都只有这一个Activity.</li>
<li>finishOnTaskLaunch 与clearTaskOnLaunch类似,只不过clearTaskOnLaunch作用在别人身上,而finishOnTaskLaunch作用在自己身上.通过这个属性,当离开这个Activity所处的Task,那么用户再返回时,该Activity就会被finish掉.</li>
<li>alwaysRetainTaskState<br>这个属性给了Task一道”免死金牌”,如果将Activity这个属性设置为True,那么该Activity所在的Task将不接受任何清理命令</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Activity_u7684_u81EA_u52A8_u9500_u6BC1_u4FDD_u5B58_u6570_u636E_u673A_u5236_u2013onSaveInstanceState"><a href="#Activity_u7684_u81EA_u52A8_u9500_u6BC1_u4FDD_u5B58_u6570_u636E_u673A_u5236_u2013onSaveInstanceState" class="headerlink" title="Activity的自动销毁保存数据机制–onSaveInstanceState"></a>Activity的自动销毁保存数据机制–onSaveInstanceState</h2><h3 id="u5BF9_u4E8E_u8FD9_u4E24_u4E2A_u65B9_u6CD5_u7684_u89E6_u53D1_u65F6_u673A_3A"><a href="#u5BF9_u4E8E_u8FD9_u4E24_u4E2A_u65B9_u6CD5_u7684_u89E6_u53D1_u65F6_u673A_3A" class="headerlink" title="对于这两个方法的触发时机:"></a>对于这两个方法的触发时机:</h3><ul>
<li><a href="http://android.blog.51cto.com/268543/634646/" target="_blank" rel="external">onSaveInstanceState和onRestoreInstanceState触发的时机</a>(16/01/28)<br>(关键字:onSaveInstanceState、onRestoreInstanceState、触发时机)</li>
<li><a href="http://www.cnblogs.com/SharkBin/p/3539658.html" target="_blank" rel="external">onSaveInstanceState(Bundle outState)的调用时机</a>(16/01/28)<br>(关键字:onSaveInstanceState、没有PersistableBundle)<br><strong>注意:是没有PersistableBundle参数的onSaveInstanceState.</strong></li>
</ul>
<h3 id="u5BF9_u4E8E_Android_L_u4E2D_u65B0_u52A0_u5165_u7684_u5E26_u6709PersistableBundle_u53C2_u6570_u7684_u4E09_u4E2A_u65B9_u6CD5_u7684_u4ECB_u7ECD_3A"><a href="#u5BF9_u4E8E_Android_L_u4E2D_u65B0_u52A0_u5165_u7684_u5E26_u6709PersistableBundle_u53C2_u6570_u7684_u4E09_u4E2A_u65B9_u6CD5_u7684_u4ECB_u7ECD_3A" class="headerlink" title="对于 Android L中新加入的带有PersistableBundle参数的三个方法的介绍:"></a>对于 Android L中新加入的带有PersistableBundle参数的三个方法的介绍:</h3><ul>
<li><a href="http://blog.csdn.net/lincyang/article/details/45287599" target="_blank" rel="external">Android实战技巧之二十六：persistableMode与Activity的持久化
</a>(16/01/28)<br>(关键字:PersistableBundle,持久化,activity)</li>
</ul>
<hr>
<h1 id="android_Fragment"><a href="#android_Fragment" class="headerlink" title="android Fragment"></a>android Fragment</h1><h2 id="Fragment_u4E0EActivity_u7684_u4EA4_u4E92"><a href="#Fragment_u4E0EActivity_u7684_u4EA4_u4E92" class="headerlink" title="Fragment与Activity的交互"></a>Fragment与Activity的交互</h2><ul>
<li><a href="http://www.cnblogs.com/dyllove98/archive/2013/07/12/3186932.html" target="_blank" rel="external">API拾遗录之Fragment(其中有各种Menus的交互)</a>(16/01/25)<br>(关键字:OptionsMenu交互,setHasOptionsMenu,Fragment,回调)</li>
</ul>
<hr>
<h1 id="android_View"><a href="#android_View" class="headerlink" title="android View"></a>android View</h1><h2 id="onSizeChange"><a href="#onSizeChange" class="headerlink" title="onSizeChange"></a>onSizeChange</h2><ul>
<li><a href="http://www.tuicool.com/articles/Vfy2I3" target="_blank" rel="external">android 系统回调onSizeChange, onMeasure, onLayout调用时机</a>(16/01/22)</li>
<li><a href="http://blog.csdn.net/jason0539/article/details/9896743" target="_blank" rel="external">android之View的启动过程,有简单的onSizeChange调用时机分析</a>(16/01/22)</li>
</ul>
<h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h2><ul>
<li><a href="http://blog.sina.com.cn/s/blog_5da93c8f0101d4mx.html" target="_blank" rel="external">Android中Paint字体属性的设置</a>(16/01/22)<br>(关键字:Paint,Style,FIll,STROKE)</li>
<li><a href="http://kalogen.iteye.com/blog/1566111" target="_blank" rel="external">android中invalidate()的自动清屏含义以及屏幕刷新</a>(16/01/22)<br>(关键字:invalidate,onDraw)</li>
<li><a href="http://blog.sina.com.cn/s/blog_783ede0301012im3.html" target="_blank" rel="external">Android Canvas drawArc方法介绍</a>(16/01/22)<br>(关键字:弧形,drawArc,canvas)</li>
<li><a href="http://blog.csdn.net/qinjuning/article/details/7110211/" target="_blank" rel="external">Android中View绘制流程以及invalidate()等相关方法分析</a>(16/01/22)<br>(关键字:invalidate,绘制流程,onDraw)</li>
</ul>
<h2 id="u81EA_u5B9A_u4E49ViewGroup_u8FC7_u7A0B"><a href="#u81EA_u5B9A_u4E49ViewGroup_u8FC7_u7A0B" class="headerlink" title="自定义ViewGroup过程"></a>自定义ViewGroup过程</h2><h3 id="u4E0E_View__u5171_u6709_u4F46_u4E0D_u7C7B_u4F3C_u7684_u7ED8_u5236_u8FC7_u7A0B"><a href="#u4E0E_View__u5171_u6709_u4F46_u4E0D_u7C7B_u4F3C_u7684_u7ED8_u5236_u8FC7_u7A0B" class="headerlink" title="与 View 共有但不类似的绘制过程"></a>与 View 共有但不类似的绘制过程</h3><ul>
<li><a href="/Android onMeasure、Measure、measureChild、measureChildren 一些简要说明">Android onMeasure、Measure、measureChild、measureChildren 一些简要说明</a>(16/01/24)<br>(关键字:measureChild,ViewGroup)</li>
</ul>
<h3 id="u5173_u4E8EViewGroup_u4E2D_u7684Scroller_u7B80_u4ECB"><a href="#u5173_u4E8EViewGroup_u4E2D_u7684Scroller_u7B80_u4ECB" class="headerlink" title="关于ViewGroup中的Scroller简介"></a>关于ViewGroup中的Scroller简介</h3><ul>
<li><a href="http://ipjmc.iteye.com/blog/1615828" target="_blank" rel="external">Android Scroller简单用法</a>(16/01/24)<br>(关键字:Scroller,ViewGroup)</li>
<li><a href="http://www.cnblogs.com/supersugar/archive/2012/08/13/2636691.html" target="_blank" rel="external">Android中Scroller类的分析</a>(16/01/24)<br>(关键字:Scroller,invalidate,computeScroll)</li>
<li><a href="http://blog.csdn.net/c_weibin/article/details/7438323" target="_blank" rel="external">android 使用Scroller实现缓慢移动</a>(16/01/24)<br>(关键字:Scroller,computeScroll调用时机)</li>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/0413/1162.html" target="_blank" rel="external">对于getScrollX() 的理解</a>(16/01/24)<br>(关键字:SCroller,getScrollX)</li>
<li><strong><a href="http://www.cnblogs.com/wanqieddy/archive/2012/05/05/2484534.html" target="_blank" rel="external">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a></strong>(16/01/24)<br>(关键字:滑屏,Scroller)</li>
</ul>
<h3 id="u4F7F_u7528ViewDragHelper_u505A_u51FA_u66F4_u597D_u7684_u6ED1_u52A8_u5B9A_u5236_u6548_u679C"><a href="#u4F7F_u7528ViewDragHelper_u505A_u51FA_u66F4_u597D_u7684_u6ED1_u52A8_u5B9A_u5236_u6548_u679C" class="headerlink" title="使用ViewDragHelper做出更好的滑动定制效果"></a>使用ViewDragHelper做出更好的滑动定制效果</h3><ul>
<li><strong><a href="http://blog.csdn.net/lmj623565791/article/details/46858663" target="_blank" rel="external">Android ViewDragHelper完全解析 自定义ViewGroup神器</a></strong>(16/01/25)<br>(关键字:ViewDragHelper,侧滑,边界捕获,非正常捕获,事件消耗,滑动事件周期)</li>
</ul>
<h3 id="u4E00_u4E9B_u5B9E_u7528_u6280_u5DE7"><a href="#u4E00_u4E9B_u5B9E_u7528_u6280_u5DE7" class="headerlink" title="一些实用技巧"></a>一些实用技巧</h3><ul>
<li><a href="http://doc.okbase.net/zpj779878443/archive/121670.html" target="_blank" rel="external">New UI-妙用view的keepScreenOn属性保持屏幕常亮</a>(16/01/27)<br>(关键字:常亮)</li>
</ul>
<hr>
<h1 id="android__u5217_u8868"><a href="#android__u5217_u8868" class="headerlink" title="android 列表"></a>android 列表</h1><h2 id="u5BF9_u4E8E_u9B45_u65CF_u4E2D_u7684ListView_u4F1A_u51FA_u73B0_u4E0B_u62C9_u60AC_u505C_u7684_u89E3_u51B3_u65B9_u6CD5"><a href="#u5BF9_u4E8E_u9B45_u65CF_u4E2D_u7684ListView_u4F1A_u51FA_u73B0_u4E0B_u62C9_u60AC_u505C_u7684_u89E3_u51B3_u65B9_u6CD5" class="headerlink" title="对于魅族中的ListView会出现下拉悬停的解决方法"></a>对于魅族中的ListView会出现下拉悬停的解决方法</h2><ul>
<li><a href="http://blog.csdn.net/guijiaoba/article/details/41725795" target="_blank" rel="external">魅族手机中屏蔽ListView下拉悬停方法</a>(16/01/24)<br>(关键字:ListView,魅族适配,下拉悬停)</li>
</ul>
<h2 id="u5217_u8868_u4E2D_u7684_u5176_u4ED6_u6709_u7528_u90E8_u5206"><a href="#u5217_u8868_u4E2D_u7684_u5176_u4ED6_u6709_u7528_u90E8_u5206" class="headerlink" title="列表中的其他有用部分"></a>列表中的其他有用部分</h2><ul>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/0225/907.html" target="_blank" rel="external">ViewConfiguration.getScaledTouchSlop () 用法</a><br>(关键字:ViewConfiguration,ScaleTouchSlop,各种列表参数)</li>
</ul>
<hr>
<h1 id="android__u56FE_u50CF_u5904_u7406"><a href="#android__u56FE_u50CF_u5904_u7406" class="headerlink" title="android 图像处理"></a>android 图像处理</h1><h2 id="u4F7F_u7528bitmap_xml_u505A_u6210_u6709_u91CD_u590D_u6392_u7248_u6548_u679C_u7684drawable_u8D44_u6E90_u6548_u679C"><a href="#u4F7F_u7528bitmap_xml_u505A_u6210_u6709_u91CD_u590D_u6392_u7248_u6548_u679C_u7684drawable_u8D44_u6E90_u6548_u679C" class="headerlink" title="使用bitmap xml做成有重复排版效果的drawable资源效果"></a>使用bitmap xml做成有重复排版效果的drawable资源效果</h2><ul>
<li><a href="http://www.2cto.com/kf/201304/205818.html" target="_blank" rel="external">XML Bitmap</a>(16/01/26)<br>(关键字:Bitmap,xml,tileMode)</li>
</ul>
<h2 id="u4F7F_u7528Shape_u505A_u51FA_u5404_u79CD_u6709_u8DA3_u7684_u6548_u679C"><a href="#u4F7F_u7528Shape_u505A_u51FA_u5404_u79CD_u6709_u8DA3_u7684_u6548_u679C" class="headerlink" title="使用Shape做出各种有趣的效果"></a>使用Shape做出各种有趣的效果</h2><h3 id="Shape_u4E2D_u7684Gradient_u4E0B_u7684Angle_u5C5E_u6027_u7684_u4F5C_u7528_u8BE6_u89E3"><a href="#Shape_u4E2D_u7684Gradient_u4E0B_u7684Angle_u5C5E_u6027_u7684_u4F5C_u7528_u8BE6_u89E3" class="headerlink" title="Shape中的Gradient下的Angle属性的作用详解"></a>Shape中的Gradient下的Angle属性的作用详解</h3><ul>
<li><a href="http://blog.csdn.net/loongggdroid/article/details/9464173" target="_blank" rel="external">Android (shape,gradient)使用总结</a>(16/01/26)<br>(关键字:Shape,Gradient,Angle)</li>
</ul>
<h2 id="u4F7F_u7528Shader_u5BF9_u753B_u7B14_u6216_u8005_u56FE_u50CF_u8FDB_u884C_u64CD_u4F5C_u5904_u7406"><a href="#u4F7F_u7528Shader_u5BF9_u753B_u7B14_u6216_u8005_u56FE_u50CF_u8FDB_u884C_u64CD_u4F5C_u5904_u7406" class="headerlink" title="使用Shader对画笔或者图像进行操作处理"></a>使用Shader对画笔或者图像进行操作处理</h2><ul>
<li><a href="http://www.php100.com/html/it/qianduan/2014/1226/8188.html" target="_blank" rel="external">Android BitmapShader实现圆形和圆角图片</a>(16/01/23)<br>(关键字:Shader,圆角)</li>
<li><a href="http://blog.csdn.net/sjf0115/article/details/7267220" target="_blank" rel="external">Android学习笔记进阶15之Shader渲染</a>(16/01/23)<br>(关键字:Shader,图片渲染)</li>
</ul>
<h2 id="u4F7F_u7528Xfermode_u5B9E_u73B0_u56FE_u7247_u6DF7_u5408_u6548_u679C"><a href="#u4F7F_u7528Xfermode_u5B9E_u73B0_u56FE_u7247_u6DF7_u5408_u6548_u679C" class="headerlink" title="使用Xfermode实现图片混合效果"></a>使用Xfermode实现图片混合效果</h2><p><a href="http://blog.csdn.net/lmj623565791/article/details/24555655" target="_blank" rel="external"></a>(16/01/27)<br>(关键字:Xfermode,圆角图片,混合图层,混合通道))</p>
<hr>
<h1 id="android_u7CFB_u7EDF"><a href="#android_u7CFB_u7EDF" class="headerlink" title="android系统"></a>android系统</h1><h2 id="u83B7_u53D6android_u8BBE_u5907_u4E2D_u7684_u53EF_u7528_u5185_u5B58"><a href="#u83B7_u53D6android_u8BBE_u5907_u4E2D_u7684_u53EF_u7528_u5185_u5B58" class="headerlink" title="获取android设备中的可用内存"></a>获取android设备中的可用内存</h2><blockquote>
<p>ActivityManager.MemoryInfo中有几个非常重要的字段,availMem–系统可能上,totalMem–总内存,threshold–低内存的阈值,即区分是否低内在的临界值,lowMemory–是否处于低 内存.</p>
</blockquote>
<ul>
<li><a href="http://blog.csdn.net/xujinsmile/article/details/8464327" target="_blank" rel="external">Android开发学习笔记（十二） 获取系统可用内存</a>(16/01/01)<br>(关键字:Formatter,内存,MemoryInfo)</li>
<li><blockquote>
<h4 id="anrdoid_u7FA4_u82F1_u4F20_2816/01/01_29"><a href="#anrdoid_u7FA4_u82F1_u4F20_2816/01/01_29" class="headerlink" title="anrdoid群英传(16/01/01)"></a>anrdoid群英传(16/01/01)</h4><p>使用 ActivityManager下的RunningAppProocessInfo可以获取到运行进程的信息,比如说以下信息:</p>
<ul>
<li>processName,进程名字</li>
<li>pid,进程pid</li>
<li>udi,进程uid<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用ActivityManager下的MemoryInfo去获取内存信息.</span></span><br><span class="line">ActivityManager.MemoryInfo memoryInfo = <span class="keyword">new</span> ActivityManager.MemoryInfo();</span><br><span class="line">am.getMemoryInfo(memoryInfo);</span><br><span class="line">tv.append(Formatter.formatFileSize(<span class="keyword">this</span>, memoryInfo.availMem) + <span class="string">","</span>);</span><br><span class="line">tv.append(memoryInfo.lowMemory + <span class="string">","</span>);</span><br><span class="line">tv.append(Formatter.formatFileSize(<span class="keyword">this</span>, memoryInfo.threshold) + <span class="string">","</span>);</span><br><span class="line">tv.append(Formatter.formatFileSize(<span class="keyword">this</span>, memoryInfo.totalMem) + <span class="string">","</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>这样就基本可以知道某些手机卫士的工作原理了.</p>
<blockquote>
<p>而RunningServiceInfo与上面类似可以获取所有当前运行的服务,这项功能可以用来判断服务是否存在以完成某些特定的功能,比如初始化UI,或者也类似于360的优化内存功能.<br>Debug.MemoryInfo 类中能通过pid去检索所占用的内存空间.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ActivityManager.RunningAppProcessInfo&gt; infos = am.getRunningAppProcesses();</span><br><span class="line"><span class="keyword">for</span> (ActivityManager.RunningAppProcessInfo info : infos) &#123;</span><br><span class="line">    <span class="keyword">int</span> pid = info.pid;</span><br><span class="line">    <span class="keyword">int</span> uid = info.uid;</span><br><span class="line">    String processName = info.processName;</span><br><span class="line">    Debug.MemoryInfo memoryInfo = am.getProcessMemoryInfo(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;pid&#125;)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> totalPss = memoryInfo.getTotalPss();</span><br><span class="line">    <span class="keyword">int</span> dalvikPss = memoryInfo.dalvikPss;</span><br><span class="line">    tv.append(pid + <span class="string">","</span>);</span><br><span class="line">    tv.append(uid + <span class="string">","</span>);</span><br><span class="line">    tv.append(processName + <span class="string">","</span>);</span><br><span class="line">    tv.append(totalPss + <span class="string">","</span>);</span><br><span class="line">    tv.append(dalvikPss + <span class="string">"."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>(关键字:ActivityManager,Info,应用信息,系统内存)</p>
<ul>
<li><a href="http://blog.csdn.net/hudashi/article/details/7050897" target="_blank" rel="external">Android中如何查看内存(上)</a>(16/01/01)<br>(关键字:底层,内存,pss,dalvik,ActivityManager,MemoryInfo,adb,shell)</li>
</ul>
<h2 id="u4F7F_u7528google_u63D0_u4F9B_u7684_u5DE5_u5177_u8FDB_u884C_u53CD_u7F16_u8BD1"><a href="#u4F7F_u7528google_u63D0_u4F9B_u7684_u5DE5_u5177_u8FDB_u884C_u53CD_u7F16_u8BD1" class="headerlink" title="使用google提供的工具进行反编译"></a>使用google提供的工具进行反编译</h2><blockquote>
<p>今天花了很多时间在尝试反编译,都出现很多问题的情况下,收集了很多相关的网站,以方便遇到同样问题的人能更好的解决而不必折腾.</p>
</blockquote>
<ul>
<li><a href="http://blog.csdn.net/vipzjyno1/article/details/21039349/" target="_blank" rel="external">Android APK反编译就这么简单 详解（附图）</a>(16/01/19)<br>(关键字:反编译,重打包,apktool,dex2jar,jd-gui)</li>
<li><a href="http://blog.csdn.net/aeolus1019/article/details/8119786" target="_blank" rel="external">brut.androlib.err.UndefinedResObject（完美解决）apktool反编译问题</a>(16/01/19)<br>(关键字:反编译,UndefinedResObject异常,apktool)</li>
<li><a href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="external">Apktool相关权威网站,有详细指导过程及常见问题</a>(16/01/19)<br>(关键字:apktool)</li>
<li><a href="http://blog.csdn.net/sam_zhang1984/article/details/8839175" target="_blank" rel="external">ApkTool反编译和重新打包</a>(16/01/21)<br>(关键字:apktool,重打包,签名,smali简单语法)</li>
</ul>
<h2 id="u4F7F_u7528Android_Studio_u8BBE_u7F6E_u7B7E_u540D_3B_u591A_u6E20_u9053_u6253_u5305"><a href="#u4F7F_u7528Android_Studio_u8BBE_u7F6E_u7B7E_u540D_3B_u591A_u6E20_u9053_u6253_u5305" class="headerlink" title="使用Android Studio设置签名;多渠道打包"></a>使用Android Studio设置签名;多渠道打包</h2><blockquote>
<p><em>引言</em><br>在使用apktool 进行反编译打包的,然后在手机进行安装会出现解析错误,不能安装的错误.上网看了一下,需要设置相应的签名才能安装<br><strong>(所以使用别人的资源重打包的时候如果 想覆盖别人的应用 ,就需要用到别人的签名,极大程度的保护了android的应用),但是如果仅仅用在汉化的用途,就可以用第二套应用.解决了这个疑问.</strong></p>
</blockquote>
<ul>
<li><a href="http://blog.csdn.net/yy1300326388/article/details/48344411" target="_blank" rel="external">［Android Studio 权威教程］打包、生成jks密钥、签名Apk、多渠道打包</a>(16/01/21)<br>(关键字:打包,sign,签名,密钥,多渠道)</li>
</ul>
<hr>
<h1 id="android__u8BBE_u8BA1"><a href="#android__u8BBE_u8BA1" class="headerlink" title="android 设计"></a>android 设计</h1><h2 id="Material_Design"><a href="#Material_Design" class="headerlink" title="Material Design"></a>Material Design</h2><h3 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h3><ul>
<li><a href="http://www.jianshu.com/p/79604c3ddcae" target="_blank" rel="external">Android开发：最详细的 Toolbar 开发实践总结</a>(16/02/23)<br>(关键字:Toolbar,细节)</li>
</ul>
<h3 id="u900F_u660E_u72B6_u6001_u680F_u5B9E_u6218"><a href="#u900F_u660E_u72B6_u6001_u680F_u5B9E_u6218" class="headerlink" title="透明状态栏实战"></a>透明状态栏实战</h3><ul>
<li><a href="http://www.jianshu.com/p/0acc12c29c1b" target="_blank" rel="external">Android开发：Translucent System Bar 的最佳实践</a>(16/02/23)<br>(关键字:StatusBar,状态栏,沉浸式状态栏)</li>
</ul>
<hr>
<h1 id="android__u4F18_u5316"><a href="#android__u4F18_u5316" class="headerlink" title="android 优化"></a>android 优化</h1><h2 id="android__u81EA_u5B9A_u4E49View__u4F18_u5316"><a href="#android__u81EA_u5B9A_u4E49View__u4F18_u5316" class="headerlink" title="android 自定义View 优化"></a>android 自定义View 优化</h2><ul>
<li><a href="http://www.bubuko.com/infodetail-185926.html" target="_blank" rel="external">Android中关于在onDraw或者onMeasure中创建对象提示Avoid object allocations during draw/layout operations (preallocate and reuse instead) 问题</a>(16/01/22)<br>(关键字:onDraw,优化,对象创建)</li>
<li><strong><a href="http://www.2cto.com/kf/201504/390390.html" target="_blank" rel="external">Android性能优化系列——Understanding Overdraw</a></strong>(16/01/28)<br>(关键字:OverDraw优化,开发者工具,GPU)</li>
<li><a href="http://blog.csdn.net/xu_fu/article/details/45008779" target="_blank" rel="external">Android性能优化系列——Profile GPU Rendering</a>(16/01/28)<br>(关键字:GPU渲染,开发者工具,OpenGL,关键帧)</li>
</ul>
<h2 id="u5206_u6790_u65B9_u6CD5_u5361_u987F_u7684_u795E_u5668TraceView"><a href="#u5206_u6790_u65B9_u6CD5_u5361_u987F_u7684_u795E_u5668TraceView" class="headerlink" title="分析方法卡顿的神器TraceView"></a>分析方法卡顿的神器TraceView</h2><ul>
<li><a href="http://blog.jobbole.com/78995/" target="_blank" rel="external">正确使用Android性能分析工具——TraceView</a>(16/01/28)<br>(关键字:TraceView,卡顿分析,内存优化,方法分析)</li>
</ul>
<h2 id="u8FFD_u8E2A_u5185_u5B58_u6CC4_u9732_u7684_u5723_u5668_MAT_u2013_28MemoryAnalyzerTool_29"><a href="#u8FFD_u8E2A_u5185_u5B58_u6CC4_u9732_u7684_u5723_u5668_MAT_u2013_28MemoryAnalyzerTool_29" class="headerlink" title="追踪内存泄露的圣器 MAT–(MemoryAnalyzerTool)"></a>追踪内存泄露的圣器 MAT–(MemoryAnalyzerTool)</h2><ul>
<li><a href="http://bjyzxxds.iteye.com/blog/1532937" target="_blank" rel="external">Shallow heap &amp; Retained heap的介绍</a>(16/01/28)<br>(关键字:MAT,内存泄露)</li>
<li><strong><a href="http://www.jianshu.com/p/c49f778e7acf" target="_blank" rel="external">使用Android studio分析内存泄露</a></strong>(16/01/28)<br>(关键字:MAT,内存泄露,内存优化,Handler)</li>
</ul>
<h2 id="android__u5185_u5B58_u6CC4_u9732"><a href="#android__u5185_u5B58_u6CC4_u9732" class="headerlink" title="android 内存泄露"></a>android 内存泄露</h2><h3 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>在MVP模式中,可以将Presenter中的mActivity设置成弱引用,这样如果在Presenter中要执行一些耗时操作而持有activity不能被回收导致内存泄露的情况发生.<br>那么,如果设置成弱引用不会出现随意被垃圾收集器处理的情况,而出现Presenter引用到activity对象的null情况吗?<br><strong> 答案: 在android 原生的某个地方已经将activity设置为强引用了,这也是activity的生命周期的实现原理,所以此时不需要担心这个问题,而需要注意当系统本应该清除activity时候能保证也能正常处理就行了. </strong></p>
</blockquote>
<ul>
<li><a href="http://blog.csdn.net/cyq1028/article/details/19980369" target="_blank" rel="external">Android内存泄漏分析及调试</a>(16/01/03)<br>(关键字:内存泄露,GC,Handler,MAT,引用类型)</li>
<li><a href="http://blog.csdn.net/stevenhu_223/article/details/18360397" target="_blank" rel="external">Android中的软引用(SoftRefrerence)和弱引用(WeakReference)</a>(16/01/03)<br>(关键字:引用类型,内存泄露,缓存机制)</li>
<li><a href="http://my.oschina.net/ydsakyclguozi/blog/404389?fromerr=n0OZIKDE" target="_blank" rel="external">Java 7之基础 - 强引用、弱引用、软引用、虚引用</a>(16/01/03)<br>(关键字:引用类型,生命周期)</li>
<li><a href="http://blog.sina.cn/dpool/blog/s/blog_4e1e357d0101kig2.html" target="_blank" rel="external">为什么在 activity中 使用handler为甚要声明为静态的</a>(16/01/03)<br>(关键字:Handler,内存泄露,静态类型)</li>
</ul>
<hr>
<h1 id="Android__u5DE5_u5177"><a href="#Android__u5DE5_u5177" class="headerlink" title="Android 工具"></a>Android 工具</h1><h2 id="Android__u5F00_u53D1_u5B98_u65B9IDE_3AAndroid_Studio"><a href="#Android__u5F00_u53D1_u5B98_u65B9IDE_3AAndroid_Studio" class="headerlink" title="Android 开发官方IDE:Android Studio"></a>Android 开发官方IDE:Android Studio</h2><h3 id="u5FEB_u6377_u952E_u53CA_u4F7F_u7528_u6280_u5DE7_u5927_u5168"><a href="#u5FEB_u6377_u952E_u53CA_u4F7F_u7528_u6280_u5DE7_u5927_u5168" class="headerlink" title="快捷键及使用技巧大全"></a>快捷键及使用技巧大全</h3><ul>
<li><a href="http://laobie.github.io/android/2016/02/14/android-studio-tips.html" target="_blank" rel="external">Android Studio 小技巧合集</a>(16/02/25)<br>(关键字:技巧,AS)</li>
</ul>
<hr>
<h1 id="Android__u65B0_u7279_u6027"><a href="#Android__u65B0_u7279_u6027" class="headerlink" title="Android 新特性"></a>Android 新特性</h1><h2 id="Android_6-0_MashMallow"><a href="#Android_6-0_MashMallow" class="headerlink" title="Android 6.0 MashMallow"></a>Android 6.0 MashMallow</h2><ul>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/50709663" target="_blank" rel="external">Android 6.0 运行时权限处理完全解析</a>(16/03/23)</li>
</ul>
<hr>
<h1 id="Android__u67B6_u6784"><a href="#Android__u67B6_u6784" class="headerlink" title="Android 架构"></a>Android 架构</h1><h3 id="MVP_u6A21_u5F0F"><a href="#MVP_u6A21_u5F0F" class="headerlink" title="MVP模式"></a>MVP模式</h3><ul>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/46596109" target="_blank" rel="external">浅谈 MVP in Android</a>(16/03/27)<br>(关键字:MVP)</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="android__u56DB_u5927_u7EC4_u4EF6_u4E4B_u4E00_Activity"><a href="#android__u56DB_u5927_u7EC4_u4EF6_u4E4B_u4E00_Activity" class="heade]]>
    </summary>
    
      <category term="daily" scheme="http://crainax.github.io/categories/daily/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初次探索java注解(Annotation)]]></title>
    <link href="http://crainax.github.io/2015/12/31/Java/%E5%88%9D%E6%AC%A1%E6%8E%A2%E7%B4%A2java%20%E6%B3%A8%E8%A7%A3(Annotation)/"/>
    <id>http://crainax.github.io/2015/12/31/Java/初次探索java 注解(Annotation)/</id>
    <published>2015-12-31T03:05:55.784Z</published>
    <updated>2016-03-03T15:00:42.010Z</updated>
    <content type="html"><![CDATA[<h2 id="JavaSE__u81EA_u5E26_u7684_u6CE8_u89E3"><a href="#JavaSE__u81EA_u5E26_u7684_u6CE8_u89E3" class="headerlink" title="JavaSE 自带的注解"></a>JavaSE 自带的注解</h2><p>我们可以自定义一个类,其中定义了一个方法,并用Deprecated注解去标注该方法已经过时,可以看到在main方法中调用该方法会报出警告.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此时可以看出下面这句语句编译器是发出警告的</span></span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是用到java.lang包下的@SuppressWarnings注解就可以消除该警告:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此时警告消除</span></span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u81EA_u5B9A_u4E49_u6CE8_u89E3_u5B9E_u6218"><a href="#u81EA_u5B9A_u4E49_u6CE8_u89E3_u5B9E_u6218" class="headerlink" title="自定义注解实战"></a>自定义注解实战</h2><h3 id="1-_u83B7_u53D6_u6CE8_u89E3_u7684_u4FE1_u606F"><a href="#1-_u83B7_u53D6_u6CE8_u89E3_u7684_u4FE1_u606F" class="headerlink" title="1.获取注解的信息"></a>1.获取注解的信息</h3><p>我们可以使用Intellij  IDEA快速生成注解:<br><img src="http://7xpmqf.com1.z0.glb.clouddn.com/15-12-31/70085738.jpg" alt=""></p>
<p>自定义注解类代码如下:<br><strong>Description.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Description &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>引用注解类代码如下:<br><strong>MyAnn1.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Description</span>(<span class="string">"I am class annotation"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnn1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里会报错: @Description is nuo applicable to field,因为在定义注解时候我们没有在@Target中去定义field目标.所以我们</span></span><br><span class="line">    <span class="meta">@Description</span>(<span class="string">"I am field annotation"</span>)</span><br><span class="line">    <span class="keyword">private</span> String testField;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Description</span>(<span class="string">"I am method annotation"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再写一个解析处理器去处理这些注解信息,其中main方法入口也在这里:</p>
<h4 id="u5904_u7406_u81EA_u5B9A_u4E49_u6CE8_u89E3_u7684_u6B65_u9AA4_3A"><a href="#u5904_u7406_u81EA_u5B9A_u4E49_u6CE8_u89E3_u7684_u6B65_u9AA4_3A" class="headerlink" title="处理自定义注解的步骤:"></a>处理自定义注解的步骤:</h4><ol>
<li>首先用java 提供的反射方法获取类加载器</li>
<li>使用getAnnotation找到类下的注解,并获取其中已经定义的值.</li>
<li>再用类加载器的方法获取所有method,遍历判断是否有注解并获取到注解,从而获取到值.<br><strong>ParseAnn.java</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseAnn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//首先用java 提供的反射方法获取类加载器</span></span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">"diy.MyAnn1"</span>);<span class="comment">//这里需要注意加上包名不然会抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(Description.class)) &#123;</span><br><span class="line">                <span class="comment">//获取到类注解</span></span><br><span class="line">                Description description = clazz.getAnnotation(Description.class);</span><br><span class="line">                System.out.println(description.value());<span class="comment">//value()方法就是定义在注解类中的一个方法.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取方法下的类注解</span></span><br><span class="line">            Method[] methods = clazz.getMethods();</span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.isAnnotationPresent(Description.class)) &#123;</span><br><span class="line">                    Description description = method.getAnnotation(Description.class);</span><br><span class="line">                    System.out.println(description.value());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后运行,可以看到程序运行结果和预想的一样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am class annotation</span><br><span class="line">I am method annotation</span><br></pre></td></tr></table></figure></p>
<h3 id="u540E_u7EED_u66F4_u65B0_u4E2D_u2026"><a href="#u540E_u7EED_u66F4_u65B0_u4E2D_u2026" class="headerlink" title="后续更新中…."></a>后续更新中….</h3>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="JavaSE__u81EA_u5E26_u7684_u6CE8_u89E3"><a href="#JavaSE__u81EA_u5E26_u7684_u6CE8_u89E3" class="headerlink" title="JavaSE 自带的注解"></a>]]>
    </summary>
    
      <category term="java" scheme="http://crainax.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java每日阅读笔记汇总]]></title>
    <link href="http://crainax.github.io/2015/12/30/daily/java%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/"/>
    <id>http://crainax.github.io/2015/12/30/daily/java每日阅读笔记汇总/</id>
    <published>2015-12-30T14:40:43.701Z</published>
    <updated>2016-02-05T15:25:00.159Z</updated>
    <content type="html"><![CDATA[<h1 id="java_u57FA_u672C_u7C7B_u578B"><a href="#java_u57FA_u672C_u7C7B_u578B" class="headerlink" title="java基本类型"></a>java基本类型</h1><h2 id="u56DB_u9053Java_u57FA_u7840_u9898__u4F60_u80FD_u5BF9_u51E0_u9053_uFF1F"><a href="#u56DB_u9053Java_u57FA_u7840_u9898__u4F60_u80FD_u5BF9_u51E0_u9053_uFF1F" class="headerlink" title="四道Java基础题 你能对几道？"></a>四道Java基础题 你能对几道？</h2><h3 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h3><blockquote>
<h3 id="u56DB_u9053Java_u57FA_u7840_u9898__u4F60_u80FD_u5BF9_u51E0_u9053_uFF1F_2815/12/30_29"><a href="#u56DB_u9053Java_u57FA_u7840_u9898__u4F60_u80FD_u5BF9_u51E0_u9053_uFF1F_2815/12/30_29" class="headerlink" title="四道Java基础题 你能对几道？(15/12/30)"></a><a href="http://blog.csdn.net/soul_code/article/details/50369947" target="_blank" rel="external">四道Java基础题 你能对几道？</a>(15/12/30)</h3><p>一、==符在Integer中的判断<br>二、==在String中的判断<br>三、final关键字在内部类中的作用<br>四、Integer与int的几个判断<br>(关键字: 装箱,拆箱,final,常量池)</p>
</blockquote>
<h3 id="u6269_u5C55_u9605_u8BFB"><a href="#u6269_u5C55_u9605_u8BFB" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><ul>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="external">深入剖析Java中的装箱和拆箱</a>(15/12/30)<br>(关键字:javap 反编译,装箱,拆箱, valueOf)</li>
<li><a href="http://www.jb51.net/article/31934.htm" target="_blank" rel="external">java自动装箱拆箱深入剖析</a>(15/12/30)<br>(关键字:装箱,拆箱,javaSE5.0,享元模式,flyWeight)</li>
<li><a href="http://www.cnblogs.com/iyangyuan/p/4631696.html" target="_blank" rel="external">触摸java常量池</a>(15/12/30)<br>(关键字:常量池,jvm虚拟机,编译时期,class文件构造,jvm参数,)</li>
<li><a href="http://blog.csdn.net/olanlanxiari/article/details/8104505" target="_blank" rel="external">java常量池概念</a>(15/12/30)<br>(关键字:Integer源码,常量池)</li>
</ul>
<h2 id="u5BF9_u4E8Efor_u5FAA_u73AF_u4E2D_u7684i++__u548C_++i__u7684_u63A2_u8BA8"><a href="#u5BF9_u4E8Efor_u5FAA_u73AF_u4E2D_u7684i++__u548C_++i__u7684_u63A2_u8BA8" class="headerlink" title="对于for循环中的i++ 和 ++i 的探讨"></a>对于for循环中的i++ 和 ++i 的探讨</h2><h3 id="u6700_u7B80_u5355_u7684_u9A8C_u8BC1_u65B9_u5F0F_u5C31_u662F_u5199_u4EE3_u7801_u9A8C_u8BC1_u4E00_u4E0B_3A"><a href="#u6700_u7B80_u5355_u7684_u9A8C_u8BC1_u65B9_u5F0F_u5C31_u662F_u5199_u4EE3_u7801_u9A8C_u8BC1_u4E00_u4E0B_3A" class="headerlink" title="最简单的验证方式就是写代码验证一下:"></a>最简单的验证方式就是写代码验证一下:</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong> 结果如下: </strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">i = <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>所以可以看出在结果上这两种循环并没有什么区别</p>
<ul>
<li><a href="http://www.cskaoyan.com/thread-40999-1-1.html" target="_blank" rel="external">for循环中i++是不是比++i多循环一次？</a>(16/01/24)<br>(关键字:for循环)</li>
<li><a href="http://bbs.csdn.net/topics/30253911" target="_blank" rel="external">i++和++i用在for循环语句中有什么区别？</a>(16/01/24)<br>(关键字:for循环)</li>
<li><a href="http://blog.csdn.net/zy1691/article/details/4849808" target="_blank" rel="external">for循环中i++与++i的效率探究</a>(16/01/24)<br>(关键字:for循环,效率探究)</li>
</ul>
<hr>
<h1 id="java__u6CE8_u89E3"><a href="#java__u6CE8_u89E3" class="headerlink" title="java 注解"></a>java 注解</h1><h2 id="u521D_u6B21_u63A5_u89E6java__u6CE8_u89E3_28Annotation_29"><a href="#u521D_u6B21_u63A5_u89E6java__u6CE8_u89E3_28Annotation_29" class="headerlink" title="初次接触java 注解(Annotation)"></a>初次接触java 注解(Annotation)</h2><h3 id="u6269_u5C55_u9605_u8BFB-1"><a href="#u6269_u5C55_u9605_u8BFB-1" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><ul>
<li><a href="http://blog.csdn.net/mddy2001/article/details/8291484" target="_blank" rel="external">@SuppressWarnings的使用、作用、用法</a>(15/12/31)<br>(关键字: 注解,SuppressWarnings,参数)</li>
<li><a href="http://blog.csdn.net/cighao/article/details/50295751" target="_blank" rel="external">全面解析 Java 注解</a>(15/12/31)<br>(关键字:注解, )</li>
</ul>
<hr>
<h1 id="java__u679A_u4E3E"><a href="#java__u679A_u4E3E" class="headerlink" title="java 枚举"></a>java 枚举</h1><h2 id="u521D_u6B21_u63A5_u89E6java__u679A_u4E3E_28Enum_29"><a href="#u521D_u6B21_u63A5_u89E6java__u679A_u4E3E_28Enum_29" class="headerlink" title="初次接触java 枚举(Enum)"></a>初次接触java 枚举(Enum)</h2><h3 id="u6269_u5C55_u9605_u8BFB-2"><a href="#u6269_u5C55_u9605_u8BFB-2" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><ul>
<li><a href="http://blog.csdn.net/soul_code/article/details/50440183" target="_blank" rel="external">Java高级特性枚举</a>(16/01/02)<br><a href="https://github.com/Crainax/DemoCode/blob/master/Java/Demo/Demo_Enum/EnumTest.java" target="_blank" rel="external">点击查看demo代码</a><br>(关键字:枚举)</li>
</ul>
<h1 id="java__u8BBE_u8BA1_u6A21_u5F0F"><a href="#java__u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="java 设计模式"></a>java 设计模式</h1><h2 id="u4EE3_u7406_u6A21_u5F0F_28Proxy_29"><a href="#u4EE3_u7406_u6A21_u5F0F_28Proxy_29" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h2><ul>
<li><a href="http://www.iteye.com/topic/683613/" target="_blank" rel="external">java 动态代理学习(Proxy,InvocationHandler)——自己的理解</a>(16/02/05)<br>(关键字:设计模式,Proxy,代理模式,InvocationHandler,反射,动态代理)</li>
</ul>
<h2 id="UML_u56FE_28_u7EDF_u4E00_u5EFA_u6A21_u8BED_u8A00_29"><a href="#UML_u56FE_28_u7EDF_u4E00_u5EFA_u6A21_u8BED_u8A00_29" class="headerlink" title="UML图(统一建模语言)"></a>UML图(统一建模语言)</h2><ul>
<li><a href="http://www.open-open.com/lib/view/open1328059700311.html" target="_blank" rel="external">UML类图几种关系的总结</a>(16/02/05)<br>(关键字:UML,泛化,实现,关联,聚合,组合,依赖)</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="java_u57FA_u672C_u7C7B_u578B"><a href="#java_u57FA_u672C_u7C7B_u578B" class="headerlink" title="java基本类型"></a>java基本类型</h1><h2 id="u]]>
    </summary>
    
      <category term="daily" scheme="http://crainax.github.io/categories/daily/"/>
    
  </entry>
  
</feed>
